<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 临渊羡鱼不如退而结网]]></title>
  <link href="http://wentao1990.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://wentao1990.github.io/"/>
  <updated>2017-03-17T23:30:37+08:00</updated>
  <id>http://wentao1990.github.io/</id>
  <author>
    <name><![CDATA[武文涛]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android开发之架构模式选择]]></title>
    <link href="http://wentao1990.github.io/blog/2017/03/01/android-mvp/"/>
    <updated>2017-03-01T21:20:25+08:00</updated>
    <id>http://wentao1990.github.io/blog/2017/03/01/android-mvp</id>
    <content type="html"><![CDATA[<h3>本文将会根据以下几个问题进行讨论</h3>

<h5>• 为什么要选择架构模式开发?</h5>

<h5>• 架构模式做的事情?</h5>

<h5>• 主流架构MVC、MVP的介绍及区别?</h5>

<h5>• 开发中如何选择合适的架构模式?</h5>

<h3>&mdash;&ndash;为什么要选择架构模式开发？</h3>

<p>首先，让我们思考一下为什么在Android开发中如此迫切地需要一个清晰的软件架构。</p>

<p><strong>Activity是上帝类</strong></p>

<p>该段摘自“代码大全第二版”：</p>

<blockquote><p>避免创建神类。避免创建无所不知，无所不能的上帝类。如果一个类需要花费时间从其他类中通过Get()和Set()检索数据（也说，需要深入业务并且告诉它们如何去做），所以是否应该把这些功能函数更好的组织到其它类而不是上帝类中。（Riel 1996）</p></blockquote>

<p>上帝类的维护成本很高，你很难理解正在进行的操作，并且难以测试和扩展，这就是为什么要避免创建上帝类的黄金法则。</p>

<p>然而，在Android开发中，如果你不考虑架构的话，Activity类往往会越来越大。这是因为，在Android中，允许View和其它线程共存于Activity内。其实最大的问题莫过于在Activity中同时存在业务逻辑和UI逻辑。这会增加测试和维护的成本。</p>

<p>这是为什么需要清晰架构的原因之一。不仅会造成Activity的臃肿，还会引起其他问题，如使Activity和Fragment的生命周期变复杂，以及数据绑定等。  <!--more--></p>

<h3>&mdash;&ndash;架构模式做的事情?</h3>

<p><strong>1.低耦合性（强调视图和业务分离）</strong></p>

<p>解耦可以说是程序设计最重要的一点，耦合性太高的代码不易维护，牵一发而动全身，修改bug或者需求很容易引起蝴蝶效应。</p>

<p><strong>2.可测试性（单元测试）</strong></p>

<p>项目分层明确，易进行驱动化测试，可以减少测试时间及bug的数量。</p>

<p><strong>3.高复用性和可适用性（减少冗余的代码）</strong></p>

<p>代码的有效复用可以提升性能及开发效率，优雅简洁的代码才是程序员追求的品味。</p>

<p><strong>4.模块职责划分明显（分工明确，提升阅读性）</strong></p>

<p>简单明了，一目了然，可以减轻二次开发的了解成本，试想一堆臃肿的代码如果非作者，别人该如何进行二次开发。</p>

<p><strong>5.隐藏数据（安全性高）</strong></p>

<p>不需要暴露出的数据，都应该封装隐藏起来，对数据统一加密、销毁、管理，可大大提高软件被破解的损失。</p>

<p><strong>6.有利于软件工程化管理（减少维护成本）</strong></p>

<p>一份规范的代码，可以进行工程化管理，无规矩不成方圆。</p>

<p>等等&hellip;</p>

<p><strong>由此可见，架构模式就是定义一个开发规范，大家彼此按照这个规范写代码。</strong></p>

<h3>&mdash;&ndash;主流架构（MVC&amp;MVP)的比较 ?</h3>

<h4>MVC（ModelViewController）</h4>

<p>我们根据一张图来分析MVC所做的事情</p>

<p><img src="http://i.imgur.com/i45tKyT.gif" alt="" /></p>

<h4>MODEL（数据）层 ：</h4>

<p><strong>• 封装应用程序状态</strong> （封装管理应用数据）</p>

<p><strong>• 响应状态查询</strong> （响应VIEW层的请求操作数据）</p>

<p><strong>• 暴露应用程序功能</strong> （供VIEW、CONTROLLER使用的核心业务逻辑）</p>

<p><strong>• 通知更改的视图</strong> （通知VIEW层渲染最新的UI数据）</p>

<p><strong>小结：</strong> 模型代表着核心的业务逻辑和数据。（不要理解成Model只是实体类）。</p>

<h4>VIEW（视图）层 ：</h4>

<p><strong>• 呈现模型</strong> （渲染UI、显示数据）</p>

<p><strong>• 请求更新表单模型</strong> （通知MODEL层更新数据）</p>

<p><strong>• 向控制器发送用户手势</strong> （响应用户的操作，通知CONTROLLER层处理相应的业务逻辑处理）</p>

<p><strong>• 允许控制器选择的观点</strong> （根据CONTROLLER层返回的结果进行呈现）</p>

<p><strong>小结：</strong> 视图应该关注与如何展示数据，而不应该包含任何业务逻辑（业务逻辑应写在Model中）。</p>

<h4>CONTROLLER（控制器）层 ：</h4>

<p><strong>• 指示应用程序行为</strong> （操作MODEL层做出相应的业务逻辑处理）</p>

<p><strong>• 将用户操作映射到模型更新</strong>（根据VIEW层传来的用户手势，通知MODEL层更新状态）</p>

<p><strong>• 选择视图进行响应</strong> （响应VIEW层的指令）</p>

<p><strong>• 每个功能一个</strong> （一个业务逻辑的函数，是唯一的，整个项目通用）</p>

<p><strong>小结：</strong> 控制器控制着程序的逻辑，并充当着视图和模型之间的协调角色。控制器从视图层接收用户输入的信息，然后使用模型来执行特定的操作，并把最终的结果回传给视图</p>

<p><strong>总结：</strong> 由上可见，在 <strong>MVC模式</strong> 中，<strong> VIEW</strong> 层负责UI渲染和用户交互，<strong> MODEL</strong> 负责数据的维护及核心业务逻辑处理， <strong>CONTROLLER</strong> 负责把二者串起来，控制他们怎么工作。</p>

<p>不过<strong>Android</strong>开发中，<strong>VIEW</strong> 层也是可以和 <strong>MODEL</strong> 层进行双向交互的，既然和数据交互，就难免存在一些业务逻辑处理，如果把控不好，就会造成 <strong>VIEW</strong> 层掺杂的业务逻辑代码过多，偏离了 <strong>MVC模式</strong> 的设计初衷。</p>

<h4>MVP（ModelViewPresenter）</h4>

<h4>为何这个模式出来后，就能被广大的Android的程序员接受呢？</h4>

<p>MVP是在MVC的基础上演变而来的，这次的跳跃是从并不标准的MVC到MVP的一个转变，减少了 <strong>ACTIVITY</strong> 的职责，简化了 <strong>ACTIVITY</strong> 中的代码，将复杂的逻辑代码提取到了 <strong>PRESENTER</strong> 中进行处理。与之对应的好处就是，耦合度更低，更方便的进行测试。借用两张图，代表上述的转变：</p>

<p><img src="http://i.imgur.com/28YLg9u.png" alt="" /></p>

<p>转变为：</p>

<p><img src="http://i.imgur.com/V2jdQQg.png" alt="" /></p>

<h3>MVC 与 MVP 的区别</h3>

<p>如下图：</p>

<p><img src="http://i.imgur.com/GxXtsZZ.png" alt="" /></p>

<p>其实最明显的区别就是，MVC中是允许Model和View进行交互的，而MVP中很明显，Model与View之间的交互由Presenter完成。还有一点就是Presenter与View之间的交互是通过接口的。</p>

<p><strong>MVC 存在的问题：</strong></p>

<p>在 <strong>MVC</strong> 模型里，<strong>MODEL</strong> 不依赖于 <strong>VIEW</strong>，但是 <strong>view</strong> 是依赖于 <strong>MODEL</strong> 的。不仅如此，因为有一些业务逻辑在  <strong>VIEW</strong> 里实现了，导致要更改 <strong>VIEW</strong> (视图是经常根据需求变化的) 也是比较困难的，至少那些业务逻辑是无法重用的。</p>

<p><strong>把Controller和View混在一起，有什么问题？</strong></p>

<p> <strong>• 难以测试</strong> 必须手动点击，使用各种自动化的测试工具。</p>

<p> <strong>• 代码难以重用</strong> UI是很难重用，因为要求总是不同。所以，导致重复的代码四处都是，维护麻烦。</p>

<p><strong>MVP 来解决 MVC 存在的问题：</strong></p>

<p>在 <strong>MVP</strong> 里， <strong>PRESENTER</strong> 完全把 <strong>MODEL</strong> 和 <strong>VIEW</strong> 进行了分离，主要的程序逻辑在 <strong>PRESENTER</strong> 里实现。而且，<strong>PRESENTER</strong> 与具体的 <strong>VIEW </strong>是没有直接关联的，而是通过定义好的接口进行交互，从而使得在变更 <strong>VIEW</strong> 时候可以 保持<strong>PRESENTER</strong> 的不变，即重用！不仅如此，我们还可以编写测试用的 <strong>VIEW</strong> ，模拟用户的各种操作，从而实现对 <strong>PRESENTER</strong> 的测试&ndash;而不需要使用自动化的测试工具。</p>

<p>我们甚至可以在 <strong>MODEL</strong> 和 <strong>VIEW</strong> 都没有完成时候，就可以通过编写 <strong>MOCK OBJECT </strong>（即实现了 <strong>MODEL</strong> 和 <strong>VIEW</strong> 的接口，但没有具体的内容的）来测试 <strong>PRESENTER</strong> 的逻辑</p>

<h3>&mdash;&ndash;开发中如何选择合适的架构模式?</h3>

<p>这里以 <strong>APP</strong> 开发为例，如果是一款轻量级、业务逻辑不是很复杂的 <strong>APP</strong> ，那么使用 <strong>MVC</strong> 模式足够满足需求，因为代码量不大，不至于变成臃肿的 <strong>MVC</strong> ，造成不好测试及维护问题。</p>

<p>如果，开发的是一款业务逻辑复杂的 <strong>超级APP</strong> ,那么使用 <strong>MVC</strong> 模式进行开发，就会出现上面所列出的那些问题。这种情况下使用<strong>MVP</strong> 架构模式就更为妥当。有些 <strong>APP</strong> 甚至只有一个 <strong>ACTIVITY</strong>，在性能和反编译安全问题都有提升。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android第三方网络请求框架总结]]></title>
    <link href="http://wentao1990.github.io/blog/2016/10/06/android-01/"/>
    <updated>2016-10-06T22:36:35+08:00</updated>
    <id>http://wentao1990.github.io/blog/2016/10/06/android-01</id>
    <content type="html"><![CDATA[<h4>android-async-http （<a href="https://github.com/loopj/android-async-http">https://github.com/loopj/android-async-http</a>）</h4>

<p>功能：</p>

<p>•基于HttpClient；</p>

<p>•在UI线程外，异步进行http请求；</p>

<p>•在匿名回调中处理请求结果，callBback使用了Android的Handler发送消息机制在创建它的线程中执行；</p>

<p>•自动智能请求重试；</p>

<p>•持久化cookie存储，保存cookie到应用程序的SharedPreferences中；</p>

<p>开发者使用：</p>

<p>作者已经停止对该项目维护，在android 5.0 以后，不推荐使用HttpClient,所以不推荐使用此库。 <!--more--></p>

<h4>Volley  （<a href="https://github.com/stormzhang/AndroidVolley">https://github.com/stormzhang/AndroidVolley</a>）</h4>

<p>功能：</p>

<p>•基于HttpUrlConnection;</p>

<p>•封装了URL图片加载框架，支持图片加载；</p>

<p>•网络请求的排序，优先级处理</p>

<p>•缓存</p>

<p>•多级别取消请求</p>

<p>•Activity和生命周期的联动（Activity结束时同时取消所有网络请求）</p>

<p>性能：</p>

<p>可扩展性好：可支持HttpClient、HttpUrlConnection和OKHttp;</p>

<p>开发者使用：</p>

<p>封装性好，简单易用。</p>

<p>应用场景：</p>

<p>• 适合简单轻量级网络交互：网络请求频繁，传输数据小；</p>

<p>• 不能进行大数据量的网络操作（下载视频、音频等），所以不适合用来上传文件；</p>

<p>备注：Volley的request和response都是吧数据放到byte数组里，不支持输入输出流，把数据放到数组中，如果大文件多了，数组就会非常的大
且多，消耗内存，所以不如直接返回Stream那样具备可操作性，比如下载一个大文件，不可能把整个文件都缓存到内存之后在写到文件里。</p>

<h4>OKHttp （<a href="https://github.com/square/okhttp">https://github.com/square/okhttp</a>）</h4>

<p>功能：</p>

<p>• 高性能Http请求库，可以把它理解成是一个封装之后类似HttpUrlConnection的东西，属于同级并不是基于上述二者；</p>

<p>• 支持SPDY，共享同一个Socket来处理同一个服务器的所有请求；</p>

<p>• 支持http 2.0、websocket；</p>

<p>• 支持同步、异步；</p>

<p>• 封装了线程池、数据转换、参数使用、错误处理等；</p>

<p>• 无缝的支持GZIP来减少数据流量；</p>

<p>• 缓存响应数据来减少重复的网络请求</p>

<p>• 能从很多常用的连接问题中自动恢复；</p>

<p>• 解决了代理服务器问题和SSL握手失败问题；</p>

<p>性能：</p>

<p>基于NIO 和 Okio，所有性能更好：请求、处理速度快（IO:阻塞式； NIO：非阻塞式；Okio 是 Square 公司基于 IO 和NIO 基础上做的一个更简单、高效处理数据流的一个库）；</p>

<p>开发者使用：</p>

<p>• Api调用更加简单、方便；</p>

<p>• 使用时需要进行多一层封装；</p>

<p>应用场景：</p>

<p>重量级网络交互场景：网络请求频繁、传输数据量大（其实更推荐Retrofit,反正Retrofit是基于 OKHttp的）；</p>

<p>备注：</p>

<p>Android 4.4 的源码中可以看到，HttpUrlConnection已经替换成OkHttp实现了，所以我们更有理由相信OkHttp的强大；</p>

<h4>Retrofit （<a href="https://github.com/square/retrofit">https://github.com/square/retrofit</a>）</h4>

<p>功能：</p>

<p>• 基于OkHttp</p>

<p>• RESTful Api 设计风格</p>

<p>• 支持同步、异步；</p>

<p>• 通过注解配置请求（包括请求方法、请求参数、请求头、返回值等）</p>

<p>• 可以搭配多种Connverter 将获得的数据解析&amp;序列化</p>

<p>• 支持Gson(默认）、Jackson 、Protobuf等</p>

<p>• 支持对 RXjava 的支持；</p>

<p>性能：</p>

<p>• 性能最好，处理最快；</p>

<p>• 扩展性差（高度封装所带来的必然后果；解析数据都是使用统一的converter，如果服务器不能给出统一的API形式，将很难进行处理。</p>

<p>开发者使用：</p>

<p>• 简洁易用（RestfulAPI设计风格）；</p>

<p>• 代码简化（更加高度的封装和注解用法）；</p>

<p>• 解耦的更彻底、职责更细分；</p>

<p>• 易于其它框架联合使用（RXjava）；</p>

<p>• 使用方法较多，原理复杂，存在一定门槛；</p>

<p>应用场景：</p>

<p>任何场景下优先选择，特别是：后台API遵循RESTful的风格&amp;项目中有使用RXjava;</p>

<h4>总结：</h4>

<p>网络请求库没有说哪个最好，只有最合适，只有真的了解其使用场景才能很好的选择网络请求库。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化]]></title>
    <link href="http://wentao1990.github.io/blog/2016/08/09/android-01/"/>
    <updated>2016-08-09T19:50:35+08:00</updated>
    <id>http://wentao1990.github.io/blog/2016/08/09/android-01</id>
    <content type="html"><![CDATA[<h4>网络相关优化</h4>

<p>1.http头信息带Cache-Control域，确定缓存过期时间，防止重复请求。</p>

<p>2.直接用IP直连，不用域名，策略性更新本地IP列表。-DNS解析过程耗时百毫秒左右，并且还有可能存在DNS劫持。</p>

<p>3.图片、JS、CSS等静态资源，采用CDN（7牛之类的第三方服务已经搭建部署好了）</p>

<p>4.全局图片处理采用漏斗模型全局掌控，所请求的图片大小依照业务大小提供（最大不超过屏幕分辨率需要），如果请求原图，也不要超过 GL10.GL_MAX_TEXTURE_SIZE。</p>

<p>5.全局缩略图直接采用webp，在尽可能不损失图片质量的前提下，图片大小与png缩小30%~70%。 <!--more--></p>

<p>6.如果列表里的缩略图服务器处理好的小图，可以考虑直接在列表数据请求中，直接以base64在列表数据中直接带上图片（国内还比较少，海外有些这种做法，好像web端比较常见）</p>

<p>7.轮询或者socket心跳采用系统 AlarmManager提供的闹钟服务来做，保证在系统休眠的时候cpu可以得到休眠，在需要唤醒时可以唤醒（持有cpu唤醒锁）</p>

<p>8.可以通过将零散的网路的请求打包进行一次操作，避免过多的无线信号引起电量消耗。</p>

<h4>传输数据格式选择</h4>

<p>1.如果是需要全局数据的，考虑使用Protobuffers(序列化反序列化性能高于Json)，并且考虑使用 nano protocol buffer。</p>

<p>2.如果传输回来的数据不需要全量读取，考虑使用 Flatbuffers (序列化反序列化几乎不耗时，耗时是在读取对象时(就这一部分如果需要优化，可以参看 Flatbuffer Use Optimize</p>

<h4>输入流</h4>

<p>使用具有缓存策略的输入流</p>

<pre><code>   原            建议替换为
InputStream    BufferedInputStream
Reader         BufferedReader
</code></pre>

<h4>数据结构</h4>

<p>如果已知大概需要多大，就直接给初始大小，减少扩容时额外开销。</p>

<p>•ArrayList :里面就一数据，内存小，有序取值快，扩容效率低。</p>

<p>•LinkedList :里面就一双向链表，内存大，随机插入删除快，扩容率高。</p>

<p>•HashSet :里面就HashMap,用key对外存储，目的就是不允许重复元素。</p>

<p>•ConcruuenHashMap :线程安全，采用细分锁，锁颗粒更小，并发性能更优.</p>

<p>•Collections.synchronizedMap : 线程安全，采用当前对象作为锁，颗粒较大，并发性能较差。</p>

<p>•SparseArray、 SparseBooleanArray、 SparseIntArray: 针对Key为 Int、 Boolean进行了优化，采用二分法查找，简单数组存储。相比 HashMap而言， HashMap每添加一个数据，大约会需要申请额外的32字节的数据，因此 Sparsexxx在内存方面的开销会小很多。</p>

<h4>编码习惯</h4>

<p>1.尽量简化，不做没必要的操作。</p>

<p>2.尽量避免分配内存（创建对象）。</p>

<p>3.如果你确定不需要访问类成员，就把方法static，这样调用速度可以提升15%~20%，因为不需要切换对象状态。</p>

<p>4.如果某个参数是常量，要加上static final ,这样可以让Class首次初始化的时候不用调用<clinit>来创建 static方法，而是在编译时就直接将常量替换代码中使用的位置。</p>

<p>5.Android开发中，类内尽量避免通过 get/set访问成员变量，虽然这在语言的开发中是一个好的习惯，但是Android虚拟机中，对方法的调用开销远大于对变量的直接访问。在没有JIT的情况下，直接的变量访问比调用方法快3倍，在JIT下，直接的变量访问更是比调用方法快7倍!</p>

<p>6.当内部类需要访问外部类的私有 方法/变量时，考虑将这些外部类的私有 方法/变量改用包可见的方式。首先在编写代码的时候，通过内部类访问外部类的私有 方法/变量是合法的，但是在编译的时候为了满足这个会将需要被内部类访问的私有 方法/变量封装一层包可见的方法，实现让内部类访问这些私有的 方法/变量，根据前面我们有提到说方法的调用开销大于变量的调用，因此这样使得性能变差，所以我们在编码的时候可以考虑直接将需要被内部类调用的外部类私有 方法/变量，改为包可见。</p>

<p>7.尽量少使用 float。在很多现代设备中， double的性能与 float的性能几乎没有差别，但是从大小上面 double是 float的两倍的大小。</p>

<p>8.尽量考虑使用整型而非浮点数，在较好的Android设备中，浮点数比整型慢一倍。</p>

<p>9.尽量不要使用除法操作，有很多处理器有乘法器，但是没有除法器，也就是说在这些设备中需要将除法分解为其他的计算方式速度会比较慢。</p>

<p>10.尽量使用系统sdk中提供的方法，而非自己去实现。如 String.indexOf()相关的API，Dalvik将会替换为内部方法； System.arraycopy()方法在Nexus One手机上，会比我们上层写的类似方法的执行速度快9倍。</p>

<p>11.谨慎编写native，性能不一定更好，Native并不是用于使得性能更好，而是用于有些已经存在的库是使用native语言实现的，我们需要引入Android，这时才使用。1) 需要多出开销在维持Java-native的通信；2) 在native中创建的资源由于在native heap上面，因此需要主动的释放；3) 需要对不同的处理器架构进行支持，存在明显的兼容性问题需要解决。</p>

<p>12.在没有JIT的设备中，面向接口编程的模式(如 Map map)，相比直接访问对象类(如 HashMap map)，会慢6%，但是在存在JIT的设备中，两者的速度差不多。但是内存占用方面面向接口变成会消耗更多内存，因此如果你的面向接口编程不是十分的必要的情况下可以考虑不用。</p>

<p>13.在没有JIT的设备中，访问本地化变量相对与成员变量会快20%，但是在存在JIT的设备中，两者速度差不多。</p>

<h4>遍历优化</h4>

<p>尽量使用 Iterable而不是通过长度判断来进行遍历。</p>

<pre><code>// 这种性能是最差的，JIT也无法对其优化。
public void zero() {
    int sum = 0;
    for (int i = 0; i &lt; mArray.length; ++i) {
        sum += mArray[i].mSplat;
    }
}
// 相对zero()来说，这种写法会更快些，在存在JIT的情况下速度几乎和two()速度一样快。
public void one() {
    int sum = 0;
    // 1) 通过本地化变量，减少查询，在不存在JIT的手机下，优化较明显。
    Foo[] localArray = mArray;
    // 2) 获取队列长度，减少每次遍历访问变量的长度，有效优化。
    int len = localArray.length;
    for (int i = 0; i &lt; len; ++i) {
        sum += localArray[i].mSplat;
    }
}
// 在无JIT的设备中，是最快的遍历方式，在存在JIT的设备中，与one()差不多快。
public void two() {
    int sum = 0;
    for (Foo a : mArray) {
        sum += a.mSplat;
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[转：Android最佳性能实践——合理管理内存]]></title>
    <link href="http://wentao1990.github.io/blog/2016/08/07/android-performs1/"/>
    <updated>2016-08-07T13:42:26+08:00</updated>
    <id>http://wentao1990.github.io/blog/2016/08/07/android-performs1</id>
    <content type="html"><![CDATA[<p>原文：<a href="http://blog.csdn.net/guolin_blog/article/details/42238627">http://blog.csdn.net/guolin_blog/article/details/42238627</a></p>

<p>注意本系列文章的内容基本源于Android Doc，如果想要阅读更加详细的关于性能方面的资料，可以直接去阅读Android官方文档。</p>

<p>内存(RAM)对于任何一个软件开发环境都是种非常珍贵的资源，而对于移动操作系统来讲的话，则会显得更加珍贵，因为手机的硬件条件相对于PC毕竟是比较落后的。尽管Android系统的虚拟机拥有自动回收垃圾的机制，但这并不代表我们就可以忽视应该在什么时候分配和释放内存。</p>

<p>为了使垃圾回收器可以正常释放程序所占用的内存，在编写代码的时候就一定要注意尽量避免出现内存泄漏的情况（通常都是由于全局成员变量持有对象引用所导致的），并且在适当的时候去释放对象引用。对于大多数的应用程序而言，后面其它的事情就可以都交给垃圾回收器去完成了，如果一个对象的引用不再被其它对象所持有，那么系统就会将这个对象所分配的内存进行回收。</p>

<p>我们在开发软件的时候应当自始至终都把内存的问题充分考虑进去，这样的话才能开发出更加高性能的软件。而内存问题也并不是无规律可行的，Android系统给我们提出了很多内存优化的建议技巧，只要按照这些技巧来编写程序，就可以让我们的程序在内存性能发面表现得相当不错，下面我们就来一一学习一下这些技巧。  <!--more--></p>

<h3>节制地使用Service</h3>

<p>如果应用程序当中需要使用Service来执行后台任务的话，请一定要注意只有当任务正在执行的时候才应该让Service运行起来。另外，当任务执行完之后去停止Service的时候，要小心Service停止失败导致内存泄漏的情况。</p>

<p>当我们启动一个Service时，系统会倾向于将这个Service所依赖的进程进行保留，这样就会导致这个进程变得非常消耗内存。并且，系统可以在LRU cache当中缓存的进程数量也会减少，导致切换应用程序的时候耗费更多性能。严重的话，甚至有可能会导致崩溃，因为系统在内存非常吃紧的时候可能已无法维护所有正在运行的Service所依赖的进程了。</p>

<p>为了能够控制Service的生命周期，Android官方推荐的最佳解决方案就是使用IntentService，这种Service的最大特点就是当后台任务执行结束后会自动停止，从而极大程度上避免了Service内存泄漏的可能性。关于IntentService更加详细的用法讲解，可以参考《第一行代码——Android》的9.5.2节。</p>

<p>让一个Service在后台一直保持运行，即使它并不执行任何工作，这是编写Android程序时最糟糕的做法之一。所以Android官方极度建议开发人员们不要过于贪婪，让Service在后台一直运行，这不仅可能会导致手机和程序的性能非常低下，而且被用户发现了之后也有可能直接导致我们的软件被卸载（我个人就会这么做）。</p>

<h3>当界面不可见时释放内存</h3>

<p>当用户打开了另外一个程序，我们的程序界面已经不再可见的时候，我们应当将所有和界面相关的资源进行释放。在这种场景下释放资源可以让系统缓存后台进程的能力显著增加，因此也会让用户体验变得更好。</p>

<p>那么我们如何才能知道程序界面是不是已经不可见了呢？其实很简单，只需要在Activity中重写onTrimMemory()方法，然后在这个方法中监听TRIM_MEMORY_UI_HIDDEN这个级别，一旦触发了之后就说明用户已经离开了我们的程序，那么此时就可以进行资源释放操作了，如下所示：</p>

<pre><code>@Override  
public void onTrimMemory(int level) {  
    super.onTrimMemory(level);  
    switch (level) {  
    case TRIM_MEMORY_UI_HIDDEN:  
        // 进行资源释放操作  
        break;  
    }  
}  
</code></pre>

<p>注意onTrimMemory()方法中的TRIM_MEMORY_UI_HIDDEN回调只有当我们程序中的所有UI组件全部不可见的时候才会触发，这和onStop()方法还是有很大区别的，因为onStop()方法只是当一个Activity完全不可见的时候就会调用，比如说用户打开了我们程序中的另一个Activity。因此，我们可以在onStop()方法中去释放一些Activity相关的资源，比如说取消网络连接或者注销广播接收器等，但是像UI相关的资源应该一直要等到onTrimMemory(TRIM_MEMORY_UI_HIDDEN)这个回调之后才去释放，这样可以保证如果用户只是从我们程序的一个Activity回到了另外一个Activity，界面相关的资源都不需要重新加载，从而提升响应速度。</p>

<h3>当内存紧张时释放内存</h3>

<p>除了刚才讲的TRIM_MEMORY_UI_HIDDEN这个回调，onTrimMemory()方法还有很多种其它类型的回调，可以在手机内存降低的时候及时通知我们。我们应该根据回调中传入的级别来去决定如何释放应用程序的资源：</p>

<h4>• TRIM_MEMORY_RUNNING_MODERATE    表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经有点低了，系统可能会开始根据LRU缓存规则来去杀死进程了。</h4>

<h4>• TRIM_MEMORY_RUNNING_LOW    表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经非常低了，我们应该去释放掉一些不必要的资源以提升系统的性能，同时这也会直接影响到我们应用程序的性能。</h4>

<h4>• TRIM_MEMORY_RUNNING_CRITICAL    表示应用程序仍然正常运行，但是系统已经根据LRU缓存规则杀掉了大部分缓存的进程了。这个时候我们应当尽可能地去释放任何不必要的资源，不然的话系统可能会继续杀掉所有缓存中的进程，并且开始杀掉一些本来应当保持运行的进程，比如说后台运行的服务。</h4>

<p>以上是当我们的应用程序正在运行时的回调，那么如果我们的程序目前是被缓存的，则会收到以下几种类型的回调：</p>

<h4>• TRIM_MEMORY_BACKGROUND    表示手机目前内存已经很低了，系统准备开始根据LRU缓存来清理进程。这个时候我们的程序在LRU缓存列表的最近位置，是不太可能被清理掉的，但这时去释放掉一些比较容易恢复的资源能够让手机的内存变得比较充足，从而让我们的程序更长时间地保留在缓存当中，这样当用户返回我们的程序时会感觉非常顺畅，而不是经历了一次重新启动的过程。</h4>

<h4>• TRIM_MEMORY_MODERATE    表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的中间位置，如果手机内存还得不到进一步释放的话，那么我们的程序就有被系统杀掉的风险了。</h4>

<h4>• TRIM_MEMORY_COMPLETE    表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的最边缘位置，系统会最优先考虑杀掉我们的应用程序，在这个时候应当尽可能地把一切可以释放的东西都进行释放。</h4>

<h3>避免在Bitmap上浪费内存</h3>

<p>当我们读取一个Bitmap图片的时候，有一点一定要注意，就是千万不要去加载不需要的分辨率。在一个很小的ImageView上显示一张高分辨率的图片不会带来任何视觉上的好处，但却会占用我们相当多宝贵的内存。需要仅记的一点是，将一张图片解析成一个Bitmap对象时所占用的内存并不是这个图片在硬盘中的大小，可能一张图片只有100k你觉得它并不大，但是读取到内存当中是按照像素点来算的，比如这张图片是1500<em>1000像素，使用的ARGB_8888颜色类型，那么每个像素点就会占用4个字节，总内存就是1500</em>1000*4字节，也就是5.7M，这个数据看起来就比较恐怖了。</p>

<pre><code>至于如何去压缩图片，以及更多在图片方面节省内存的技术，大家可以去参考我之前写的一篇博客 Android高效加载大图、多图解决方案，有效避免程序OOM 。
</code></pre>

<h3>使用优化过的数据集合</h3>

<p>Android API当中提供了一些优化过后的数据集合工具类，如SparseArray，SparseBooleanArray，以及LongSparseArray等，使用这些API可以让我们的程序更加高效。传统Java API中提供的HashMap工具类会相对比较低效，因为它需要为每一个键值对都提供一个对象入口，而SparseArray就避免掉了基本数据类型转换成对象数据类型的时间。</p>

<h3>知晓内存的开支情况</h3>

<p>我们还应当清楚我们所使用语言的内存开支和消耗情况，并且在整个软件的设计和开发当中都应该将这些信息考虑在内。可能有一些看起来无关痛痒的写法，结果却会导致很大一部分的内存开支，例如：
使用枚举通常会比使用静态常量要消耗两倍以上的内存，在Android开发当中我们应当尽可能地不使用枚举。
任何一个Java类，包括内部类、匿名类，都要占用大概500字节的内存空间。
任何一个类的实例要消耗12-16字节的内存开支，因此频繁创建实例也是会一定程序上影响内存的。
在使用HashMap时，即使你只设置了一个基本数据类型的键，比如说int，但是也会按照对象的大小来分配内存，大概是32字节，而不是4字节。因此最好的办法就是像上面所说的一样，使用优化过的数据集合。</p>

<h3>谨慎使用抽象编程</h3>

<p>许多程序员都喜欢各种使用抽象来编程，认为这是一种很好的编程习惯。当然，这一点不可否认，因为的抽象的编程方法更加面向对象，而且在代码的维护和可扩展性方面都会有所提高。但是，在Android上使用抽象会带来额外的内存开支，因为抽象的编程方法需要编写额外的代码，虽然这些代码根本执行不到，但是却也要映射到内存当中，不仅占用了更多的内存，在执行效率方面也会有所降低。当然这里我并不是提倡大家完全不使用抽象编程，而是谨慎使用抽象编程，不要认为这是一种很酷的编程方式而去肆意使用它，只在你认为有必要的情况下才去使用。</p>

<p>尽量避免使用依赖注入框架</p>

<p>现在有很多人都喜欢在Android工程当中使用依赖注入框架，比如说像Guice或者RoboGuice等，因为它们可以简化一些复杂的编码操作，比如可以将下面的一段代码：</p>

<pre><code>class AndroidWay extends Activity {   
    TextView name;   
    ImageView thumbnail;   
    LocationManager loc;   
    Drawable icon;   
    String myName;   

    public void onCreate(Bundle savedInstanceState) {   
        super.onCreate(savedInstanceState);   
        setContentView(R.layout.main);  
        name      = (TextView) findViewById(R.id.name);   
        thumbnail = (ImageView) findViewById(R.id.thumbnail);   
        loc       = (LocationManager) getSystemService(Activity.LOCATION_SERVICE);   
        icon      = getResources().getDrawable(R.drawable.icon);   
        myName    = getString(R.string.app_name);   
        name.setText( "Hello, " + myName );   
    }   
}   
</code></pre>

<p>简化成这样的一种写法：</p>

<pre><code>@ContentView(R.layout.main)  
class RoboWay extends RoboActivity {   
    @InjectView(R.id.name)             TextView name;   
    @InjectView(R.id.thumbnail)        ImageView thumbnail;   
    @InjectResource(R.drawable.icon)   Drawable icon;   
    @InjectResource(R.string.app_name) String myName;   
    @Inject                            LocationManager loc;   

    public void onCreate(Bundle savedInstanceState) {   
        super.onCreate(savedInstanceState);   
        name.setText( "Hello, " + myName );   
    }   
}  
</code></pre>

<p>看上去确实十分诱人，我们甚至可以将findViewById()这一类的繁琐操作全部省去了。但是这些框架为了要搜寻代码中的注解，通常都需要经历较长的初始化过程，并且还可能将一些你用不到的对象也一并加载到内存当中。这些用不到的对象会一直占用着内存空间，可能要过很久之后才会得到释放，相较之下，也许多敲几行看似繁琐的代码才是更好的选择。</p>

<h3>使用ProGuard简化代码</h3>

<p>ProGuard相信大家都不会陌生，很多人都会使用这个工具来混淆代码，但是除了混淆之外，它还具有压缩和优化代码的功能。ProGuard会对我们的代码进行检索，删除一些无用的代码，并且会对类、字段、方法等进行重命名，重命名之后的类、字段和方法名都会比原来简短很多，这样的话也就对内存的占用变得更少了。</p>

<h3>使用多个进程</h3>

<p>这个技巧其实并不是非常建议使用，但它确实是一种可以帮助我们节省和管理内存的高级技巧。如果你要使用它的话一定要谨慎使用，因为绝大多数的应用程序都不应该在多个进程当中运行的，一旦使用不当，它甚至会增加额外的内存而不是帮我们节省内存。这个技巧比较适用于那些需要在后台去完成一项独立的任务，和前台的功能是可以完全区分开的场景。</p>

<p>这里举一个比较适合去使用多进程技巧的场景，比如说我们正在做一个音乐播放器软件，其中播放音乐的功能应该是一个独立的功能，它不需要和UI方面有任何关系，即使软件已经关闭了也应该可以正常播放音乐。如果此时我们只使用一个进程，那么即使用户关闭了软件，已经完全由Service来控制音乐播放了，系统仍然会将许多UI方面的内存进行保留。在这种场景下就非常适合使用两个进程，一个用于UI展示，另一个则用于在后台持续地播放音乐。</p>

<p>想要实现多进程的功能也非常简单，只需要在AndroidManifest文件的应用程序组件中声明一个android:process属性就可以了，比如说我们希望播放音乐的Service可以运行在一个单独的进程当中，就可以这样写：</p>

<pre><code>&lt;service android:name=".PlaybackService"  
         android:process=":background" /&gt;  
</code></pre>

<p>这里指定的进程名是background，你也可以将它改成任意你喜欢的名字。需要注意的是，进程名的前面都应该加上一个冒号，表示该进程是一个当前应用程序的私有进程。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Service与 IntentService 的区别与使用场景]]></title>
    <link href="http://wentao1990.github.io/blog/2016/05/23/android-server/"/>
    <updated>2016-05-23T17:50:35+08:00</updated>
    <id>http://wentao1990.github.io/blog/2016/05/23/android-server</id>
    <content type="html"><![CDATA[<h4>1.IntentService是继承自Service的</h4>

<h4>2.Service不是一个单独的进程 ，它和应用程序在同一个进程中。</h4>

<h4>3.Service不是一个线程，所以我们应该避免在Service里面进行耗时的操作</h4>

<h4>4.IntentService相对于Service来说，有几个非常有用的优点</h4>

<p>IntentService使用队列的方式将请求的Intent加入队列，然后开启一个worker thread(线程)来处理队列中的Intent，对于异步的startService请求，IntentService会处理完成一个之后再处理第二个，每一个请求都会在一个单独的worker thread中处理，不会阻塞应用程序的主线程，这里就给我们提供了一个思路，如果有耗时的操作与其在Service里面开启新线程还不如使用IntentService来处理耗时操作。 <!--more--></p>

<p>因为最大部分的service不需要同时处理多个请求(处理多个请求是一个比较危险的多线程的场景),这样在在这种情况下呢，最好使用IntentService类如果你实现你的服务。</p>

<p>使用intentService与service有什么不同呢</p>

<h4>a . 直接 创建一个默认的工作线程,该线程执行所有的intent传递给onStartCommand()区别于应用程序的主线程。</h4>

<h4>b . 直接创建一个工作队列,将一个意图传递给你onHandleIntent()的实现,所以我们就永远不必担心多线程。</h4>

<h4>c . 当请求完成后自己会调用stopSelf()，所以你就不用调用该方法了。</h4>

<h4>d . 提供的默认实现onBind()返回null，所以也不需要重写这个方法。so easy啊</h4>

<h4>e . 提供了一个默认实现onStartCommand(),将意图工作队列,然后发送到你onHandleIntent()实现。真是太方便了</h4>

<p>我们需要做的就是实现onHandlerIntent()方法，还有一点就是经常被遗忘的，构造函数是必需的,而且必须调用超IntentService(字符串) ，因为工作线程的构造函数必须使用一个名称。如何实现呢，我们借助于谷歌官方文档来看一下吧。</p>

<pre><code>public class HelloIntentService extends IntentService {  

  /** 
   * A constructor is required, and must call the super IntentService(String) 
   * constructor with a name for the worker thread. 
   */  
  public HelloIntentService() {  
      super("HelloIntentService");  
  }  

  /** 
   * The IntentService calls this method from the default worker thread with 
   * the intent that started the service. When this method returns, IntentService 
   * stops the service, as appropriate. 
   */  
  @Override  
  protected void onHandleIntent(Intent intent) {  
      // Normally we would do some work here, like download a file.  
      // For our sample, we just sleep for 5 seconds.  
      long endTime = System.currentTimeMillis() + 5*1000;  
      while (System.currentTimeMillis() &lt; endTime) {  
          synchronized (this) {  
              try {  
                  wait(endTime - System.currentTimeMillis());  
              } catch (Exception e) {  
              }  
          }  
      }  
  }  
}  
</code></pre>

<p>那么它为什么不用stopself()方法呢，我们看一下自身的源代码吧</p>

<pre><code>    public abstract class IntentService extends Service {  
    private volatile Looper mServiceLooper;  
    private volatile ServiceHandler mServiceHandler;  
    private String mName;  
    private boolean mRedelivery;  

    private final class ServiceHandler extends Handler {  
        public ServiceHandler(Looper looper) {  
            super(looper);  
        }  

        @Override  
        public void handleMessage(Message msg) {  
            onHandleIntent((Intent)msg.obj);  
            stopSelf(msg.arg1);  
        }  
    }  

    /** 
     * Creates an IntentService.  Invoked by your subclass's constructor. 
     * 
     * @param name Used to name the worker thread, important only for debugging. 
     */  
    public IntentService(String name) {  
        super();  
        mName = name;  
    }  

    /** 
     * Sets intent redelivery preferences.  Usually called from the constructor 
     * with your preferred semantics. 
     * 
     * &lt;p&gt;If enabled is true, 
     * {@link #onStartCommand(Intent, int, int)} will return 
     * {@link Service#START_REDELIVER_INTENT}, so if this process dies before 
     * {@link #onHandleIntent(Intent)} returns, the process will be restarted 
     * and the intent redelivered.  If multiple Intents have been sent, only 
     * the most recent one is guaranteed to be redelivered. 
     * 
     * &lt;p&gt;If enabled is false (the default), 
     * {@link #onStartCommand(Intent, int, int)} will return 
     * {@link Service#START_NOT_STICKY}, and if the process dies, the Intent 
     * dies along with it. 
     */  
    public void setIntentRedelivery(boolean enabled) {  
        mRedelivery = enabled;  
    }  

    @Override  
    public void onCreate() {  
        // TODO: It would be nice to have an option to hold a partial wakelock  
        // during processing, and to have a static startService(Context, Intent)  
        // method that would launch the service &amp; hand off a wakelock.  

        super.onCreate();  
        HandlerThread thread = new HandlerThread("IntentService[" + mName + "]");  
        thread.start();  

        mServiceLooper = thread.getLooper();  
        mServiceHandler = new ServiceHandler(mServiceLooper);  
    }  

    @Override  
    public void onStart(Intent intent, int startId) {  
        Message msg = mServiceHandler.obtainMessage();  
        msg.arg1 = startId;  
        msg.obj = intent;  
        mServiceHandler.sendMessage(msg);  
    }  

    /** 
     * You should not override this method for your IntentService. Instead, 
     * override {@link #onHandleIntent}, which the system calls when the IntentService 
     * receives a start request. 
     * @see android.app.Service#onStartCommand 
     */  
    @Override  
    public int onStartCommand(Intent intent, int flags, int startId) {  
        onStart(intent, startId);  
        return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;  
    }  

    @Override  
    public void onDestroy() {  
        mServiceLooper.quit();  
    }  

    /** 
     * Unless you provide binding for your service, you don't need to implement this 
     * method, because the default implementation returns null.  
     * @see android.app.Service#onBind 
     */  
    @Override  
    public IBinder onBind(Intent intent) {  
        return null;  
    }  

    /** 
     * This method is invoked on the worker thread with a request to process. 
     * Only one Intent is processed at a time, but the processing happens on a 
     * worker thread that runs independently from other application logic. 
     * So, if this code takes a long time, it will hold up other requests to 
     * the same IntentService, but it will not hold up anything else. 
     * When all requests have been handled, the IntentService stops itself, 
     * so you should not call {@link #stopSelf}. 
     * 
     * @param intent The value passed to {@link 
     *               android.content.Context#startService(Intent)}. 
     */  
    protected abstract void onHandleIntent(Intent intent);  
}  
</code></pre>

<p>我们可以看到源代码里头的第15行handlerMessage方法里当处理完请求后就会调用stopself()方法了，外界就不用调用了，此外还有一点我们可以看到代码最后一行第110行，onhandleIntent()是一个抽象类，而其他类都是抽象类，所以我们就可以理解为什么只需要重写onhandleIntent()方法了吧。</p>
]]></content>
  </entry>
  
</feed>
