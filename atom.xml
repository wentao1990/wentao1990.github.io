<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[临渊羡鱼不如退而结网]]></title>
  <link href="http://wentao1990.github.io/atom.xml" rel="self"/>
  <link href="http://wentao1990.github.io/"/>
  <updated>2017-03-17T23:30:37+08:00</updated>
  <id>http://wentao1990.github.io/</id>
  <author>
    <name><![CDATA[武文涛]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android开发之架构模式选择]]></title>
    <link href="http://wentao1990.github.io/blog/2017/03/01/android-mvp/"/>
    <updated>2017-03-01T21:20:25+08:00</updated>
    <id>http://wentao1990.github.io/blog/2017/03/01/android-mvp</id>
    <content type="html"><![CDATA[<h3>本文将会根据以下几个问题进行讨论</h3>

<h5>• 为什么要选择架构模式开发?</h5>

<h5>• 架构模式做的事情?</h5>

<h5>• 主流架构MVC、MVP的介绍及区别?</h5>

<h5>• 开发中如何选择合适的架构模式?</h5>

<h3>&mdash;&ndash;为什么要选择架构模式开发？</h3>

<p>首先，让我们思考一下为什么在Android开发中如此迫切地需要一个清晰的软件架构。</p>

<p><strong>Activity是上帝类</strong></p>

<p>该段摘自“代码大全第二版”：</p>

<blockquote><p>避免创建神类。避免创建无所不知，无所不能的上帝类。如果一个类需要花费时间从其他类中通过Get()和Set()检索数据（也说，需要深入业务并且告诉它们如何去做），所以是否应该把这些功能函数更好的组织到其它类而不是上帝类中。（Riel 1996）</p></blockquote>

<p>上帝类的维护成本很高，你很难理解正在进行的操作，并且难以测试和扩展，这就是为什么要避免创建上帝类的黄金法则。</p>

<p>然而，在Android开发中，如果你不考虑架构的话，Activity类往往会越来越大。这是因为，在Android中，允许View和其它线程共存于Activity内。其实最大的问题莫过于在Activity中同时存在业务逻辑和UI逻辑。这会增加测试和维护的成本。</p>

<p>这是为什么需要清晰架构的原因之一。不仅会造成Activity的臃肿，还会引起其他问题，如使Activity和Fragment的生命周期变复杂，以及数据绑定等。  <!--more--></p>

<h3>&mdash;&ndash;架构模式做的事情?</h3>

<p><strong>1.低耦合性（强调视图和业务分离）</strong></p>

<p>解耦可以说是程序设计最重要的一点，耦合性太高的代码不易维护，牵一发而动全身，修改bug或者需求很容易引起蝴蝶效应。</p>

<p><strong>2.可测试性（单元测试）</strong></p>

<p>项目分层明确，易进行驱动化测试，可以减少测试时间及bug的数量。</p>

<p><strong>3.高复用性和可适用性（减少冗余的代码）</strong></p>

<p>代码的有效复用可以提升性能及开发效率，优雅简洁的代码才是程序员追求的品味。</p>

<p><strong>4.模块职责划分明显（分工明确，提升阅读性）</strong></p>

<p>简单明了，一目了然，可以减轻二次开发的了解成本，试想一堆臃肿的代码如果非作者，别人该如何进行二次开发。</p>

<p><strong>5.隐藏数据（安全性高）</strong></p>

<p>不需要暴露出的数据，都应该封装隐藏起来，对数据统一加密、销毁、管理，可大大提高软件被破解的损失。</p>

<p><strong>6.有利于软件工程化管理（减少维护成本）</strong></p>

<p>一份规范的代码，可以进行工程化管理，无规矩不成方圆。</p>

<p>等等&hellip;</p>

<p><strong>由此可见，架构模式就是定义一个开发规范，大家彼此按照这个规范写代码。</strong></p>

<h3>&mdash;&ndash;主流架构（MVC&amp;MVP)的比较 ?</h3>

<h4>MVC（ModelViewController）</h4>

<p>我们根据一张图来分析MVC所做的事情</p>

<p><img src="http://i.imgur.com/i45tKyT.gif" alt="" /></p>

<h4>MODEL（数据）层 ：</h4>

<p><strong>• 封装应用程序状态</strong> （封装管理应用数据）</p>

<p><strong>• 响应状态查询</strong> （响应VIEW层的请求操作数据）</p>

<p><strong>• 暴露应用程序功能</strong> （供VIEW、CONTROLLER使用的核心业务逻辑）</p>

<p><strong>• 通知更改的视图</strong> （通知VIEW层渲染最新的UI数据）</p>

<p><strong>小结：</strong> 模型代表着核心的业务逻辑和数据。（不要理解成Model只是实体类）。</p>

<h4>VIEW（视图）层 ：</h4>

<p><strong>• 呈现模型</strong> （渲染UI、显示数据）</p>

<p><strong>• 请求更新表单模型</strong> （通知MODEL层更新数据）</p>

<p><strong>• 向控制器发送用户手势</strong> （响应用户的操作，通知CONTROLLER层处理相应的业务逻辑处理）</p>

<p><strong>• 允许控制器选择的观点</strong> （根据CONTROLLER层返回的结果进行呈现）</p>

<p><strong>小结：</strong> 视图应该关注与如何展示数据，而不应该包含任何业务逻辑（业务逻辑应写在Model中）。</p>

<h4>CONTROLLER（控制器）层 ：</h4>

<p><strong>• 指示应用程序行为</strong> （操作MODEL层做出相应的业务逻辑处理）</p>

<p><strong>• 将用户操作映射到模型更新</strong>（根据VIEW层传来的用户手势，通知MODEL层更新状态）</p>

<p><strong>• 选择视图进行响应</strong> （响应VIEW层的指令）</p>

<p><strong>• 每个功能一个</strong> （一个业务逻辑的函数，是唯一的，整个项目通用）</p>

<p><strong>小结：</strong> 控制器控制着程序的逻辑，并充当着视图和模型之间的协调角色。控制器从视图层接收用户输入的信息，然后使用模型来执行特定的操作，并把最终的结果回传给视图</p>

<p><strong>总结：</strong> 由上可见，在 <strong>MVC模式</strong> 中，<strong> VIEW</strong> 层负责UI渲染和用户交互，<strong> MODEL</strong> 负责数据的维护及核心业务逻辑处理， <strong>CONTROLLER</strong> 负责把二者串起来，控制他们怎么工作。</p>

<p>不过<strong>Android</strong>开发中，<strong>VIEW</strong> 层也是可以和 <strong>MODEL</strong> 层进行双向交互的，既然和数据交互，就难免存在一些业务逻辑处理，如果把控不好，就会造成 <strong>VIEW</strong> 层掺杂的业务逻辑代码过多，偏离了 <strong>MVC模式</strong> 的设计初衷。</p>

<h4>MVP（ModelViewPresenter）</h4>

<h4>为何这个模式出来后，就能被广大的Android的程序员接受呢？</h4>

<p>MVP是在MVC的基础上演变而来的，这次的跳跃是从并不标准的MVC到MVP的一个转变，减少了 <strong>ACTIVITY</strong> 的职责，简化了 <strong>ACTIVITY</strong> 中的代码，将复杂的逻辑代码提取到了 <strong>PRESENTER</strong> 中进行处理。与之对应的好处就是，耦合度更低，更方便的进行测试。借用两张图，代表上述的转变：</p>

<p><img src="http://i.imgur.com/28YLg9u.png" alt="" /></p>

<p>转变为：</p>

<p><img src="http://i.imgur.com/V2jdQQg.png" alt="" /></p>

<h3>MVC 与 MVP 的区别</h3>

<p>如下图：</p>

<p><img src="http://i.imgur.com/GxXtsZZ.png" alt="" /></p>

<p>其实最明显的区别就是，MVC中是允许Model和View进行交互的，而MVP中很明显，Model与View之间的交互由Presenter完成。还有一点就是Presenter与View之间的交互是通过接口的。</p>

<p><strong>MVC 存在的问题：</strong></p>

<p>在 <strong>MVC</strong> 模型里，<strong>MODEL</strong> 不依赖于 <strong>VIEW</strong>，但是 <strong>view</strong> 是依赖于 <strong>MODEL</strong> 的。不仅如此，因为有一些业务逻辑在  <strong>VIEW</strong> 里实现了，导致要更改 <strong>VIEW</strong> (视图是经常根据需求变化的) 也是比较困难的，至少那些业务逻辑是无法重用的。</p>

<p><strong>把Controller和View混在一起，有什么问题？</strong></p>

<p> <strong>• 难以测试</strong> 必须手动点击，使用各种自动化的测试工具。</p>

<p> <strong>• 代码难以重用</strong> UI是很难重用，因为要求总是不同。所以，导致重复的代码四处都是，维护麻烦。</p>

<p><strong>MVP 来解决 MVC 存在的问题：</strong></p>

<p>在 <strong>MVP</strong> 里， <strong>PRESENTER</strong> 完全把 <strong>MODEL</strong> 和 <strong>VIEW</strong> 进行了分离，主要的程序逻辑在 <strong>PRESENTER</strong> 里实现。而且，<strong>PRESENTER</strong> 与具体的 <strong>VIEW </strong>是没有直接关联的，而是通过定义好的接口进行交互，从而使得在变更 <strong>VIEW</strong> 时候可以 保持<strong>PRESENTER</strong> 的不变，即重用！不仅如此，我们还可以编写测试用的 <strong>VIEW</strong> ，模拟用户的各种操作，从而实现对 <strong>PRESENTER</strong> 的测试&ndash;而不需要使用自动化的测试工具。</p>

<p>我们甚至可以在 <strong>MODEL</strong> 和 <strong>VIEW</strong> 都没有完成时候，就可以通过编写 <strong>MOCK OBJECT </strong>（即实现了 <strong>MODEL</strong> 和 <strong>VIEW</strong> 的接口，但没有具体的内容的）来测试 <strong>PRESENTER</strong> 的逻辑</p>

<h3>&mdash;&ndash;开发中如何选择合适的架构模式?</h3>

<p>这里以 <strong>APP</strong> 开发为例，如果是一款轻量级、业务逻辑不是很复杂的 <strong>APP</strong> ，那么使用 <strong>MVC</strong> 模式足够满足需求，因为代码量不大，不至于变成臃肿的 <strong>MVC</strong> ，造成不好测试及维护问题。</p>

<p>如果，开发的是一款业务逻辑复杂的 <strong>超级APP</strong> ,那么使用 <strong>MVC</strong> 模式进行开发，就会出现上面所列出的那些问题。这种情况下使用<strong>MVP</strong> 架构模式就更为妥当。有些 <strong>APP</strong> 甚至只有一个 <strong>ACTIVITY</strong>，在性能和反编译安全问题都有提升。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android第三方网络请求框架总结]]></title>
    <link href="http://wentao1990.github.io/blog/2016/10/06/android-01/"/>
    <updated>2016-10-06T22:36:35+08:00</updated>
    <id>http://wentao1990.github.io/blog/2016/10/06/android-01</id>
    <content type="html"><![CDATA[<h4>android-async-http （<a href="https://github.com/loopj/android-async-http">https://github.com/loopj/android-async-http</a>）</h4>

<p>功能：</p>

<p>•基于HttpClient；</p>

<p>•在UI线程外，异步进行http请求；</p>

<p>•在匿名回调中处理请求结果，callBback使用了Android的Handler发送消息机制在创建它的线程中执行；</p>

<p>•自动智能请求重试；</p>

<p>•持久化cookie存储，保存cookie到应用程序的SharedPreferences中；</p>

<p>开发者使用：</p>

<p>作者已经停止对该项目维护，在android 5.0 以后，不推荐使用HttpClient,所以不推荐使用此库。 <!--more--></p>

<h4>Volley  （<a href="https://github.com/stormzhang/AndroidVolley">https://github.com/stormzhang/AndroidVolley</a>）</h4>

<p>功能：</p>

<p>•基于HttpUrlConnection;</p>

<p>•封装了URL图片加载框架，支持图片加载；</p>

<p>•网络请求的排序，优先级处理</p>

<p>•缓存</p>

<p>•多级别取消请求</p>

<p>•Activity和生命周期的联动（Activity结束时同时取消所有网络请求）</p>

<p>性能：</p>

<p>可扩展性好：可支持HttpClient、HttpUrlConnection和OKHttp;</p>

<p>开发者使用：</p>

<p>封装性好，简单易用。</p>

<p>应用场景：</p>

<p>• 适合简单轻量级网络交互：网络请求频繁，传输数据小；</p>

<p>• 不能进行大数据量的网络操作（下载视频、音频等），所以不适合用来上传文件；</p>

<p>备注：Volley的request和response都是吧数据放到byte数组里，不支持输入输出流，把数据放到数组中，如果大文件多了，数组就会非常的大
且多，消耗内存，所以不如直接返回Stream那样具备可操作性，比如下载一个大文件，不可能把整个文件都缓存到内存之后在写到文件里。</p>

<h4>OKHttp （<a href="https://github.com/square/okhttp">https://github.com/square/okhttp</a>）</h4>

<p>功能：</p>

<p>• 高性能Http请求库，可以把它理解成是一个封装之后类似HttpUrlConnection的东西，属于同级并不是基于上述二者；</p>

<p>• 支持SPDY，共享同一个Socket来处理同一个服务器的所有请求；</p>

<p>• 支持http 2.0、websocket；</p>

<p>• 支持同步、异步；</p>

<p>• 封装了线程池、数据转换、参数使用、错误处理等；</p>

<p>• 无缝的支持GZIP来减少数据流量；</p>

<p>• 缓存响应数据来减少重复的网络请求</p>

<p>• 能从很多常用的连接问题中自动恢复；</p>

<p>• 解决了代理服务器问题和SSL握手失败问题；</p>

<p>性能：</p>

<p>基于NIO 和 Okio，所有性能更好：请求、处理速度快（IO:阻塞式； NIO：非阻塞式；Okio 是 Square 公司基于 IO 和NIO 基础上做的一个更简单、高效处理数据流的一个库）；</p>

<p>开发者使用：</p>

<p>• Api调用更加简单、方便；</p>

<p>• 使用时需要进行多一层封装；</p>

<p>应用场景：</p>

<p>重量级网络交互场景：网络请求频繁、传输数据量大（其实更推荐Retrofit,反正Retrofit是基于 OKHttp的）；</p>

<p>备注：</p>

<p>Android 4.4 的源码中可以看到，HttpUrlConnection已经替换成OkHttp实现了，所以我们更有理由相信OkHttp的强大；</p>

<h4>Retrofit （<a href="https://github.com/square/retrofit">https://github.com/square/retrofit</a>）</h4>

<p>功能：</p>

<p>• 基于OkHttp</p>

<p>• RESTful Api 设计风格</p>

<p>• 支持同步、异步；</p>

<p>• 通过注解配置请求（包括请求方法、请求参数、请求头、返回值等）</p>

<p>• 可以搭配多种Connverter 将获得的数据解析&amp;序列化</p>

<p>• 支持Gson(默认）、Jackson 、Protobuf等</p>

<p>• 支持对 RXjava 的支持；</p>

<p>性能：</p>

<p>• 性能最好，处理最快；</p>

<p>• 扩展性差（高度封装所带来的必然后果；解析数据都是使用统一的converter，如果服务器不能给出统一的API形式，将很难进行处理。</p>

<p>开发者使用：</p>

<p>• 简洁易用（RestfulAPI设计风格）；</p>

<p>• 代码简化（更加高度的封装和注解用法）；</p>

<p>• 解耦的更彻底、职责更细分；</p>

<p>• 易于其它框架联合使用（RXjava）；</p>

<p>• 使用方法较多，原理复杂，存在一定门槛；</p>

<p>应用场景：</p>

<p>任何场景下优先选择，特别是：后台API遵循RESTful的风格&amp;项目中有使用RXjava;</p>

<h4>总结：</h4>

<p>网络请求库没有说哪个最好，只有最合适，只有真的了解其使用场景才能很好的选择网络请求库。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化]]></title>
    <link href="http://wentao1990.github.io/blog/2016/08/09/android-01/"/>
    <updated>2016-08-09T19:50:35+08:00</updated>
    <id>http://wentao1990.github.io/blog/2016/08/09/android-01</id>
    <content type="html"><![CDATA[<h4>网络相关优化</h4>

<p>1.http头信息带Cache-Control域，确定缓存过期时间，防止重复请求。</p>

<p>2.直接用IP直连，不用域名，策略性更新本地IP列表。-DNS解析过程耗时百毫秒左右，并且还有可能存在DNS劫持。</p>

<p>3.图片、JS、CSS等静态资源，采用CDN（7牛之类的第三方服务已经搭建部署好了）</p>

<p>4.全局图片处理采用漏斗模型全局掌控，所请求的图片大小依照业务大小提供（最大不超过屏幕分辨率需要），如果请求原图，也不要超过 GL10.GL_MAX_TEXTURE_SIZE。</p>

<p>5.全局缩略图直接采用webp，在尽可能不损失图片质量的前提下，图片大小与png缩小30%~70%。 <!--more--></p>

<p>6.如果列表里的缩略图服务器处理好的小图，可以考虑直接在列表数据请求中，直接以base64在列表数据中直接带上图片（国内还比较少，海外有些这种做法，好像web端比较常见）</p>

<p>7.轮询或者socket心跳采用系统 AlarmManager提供的闹钟服务来做，保证在系统休眠的时候cpu可以得到休眠，在需要唤醒时可以唤醒（持有cpu唤醒锁）</p>

<p>8.可以通过将零散的网路的请求打包进行一次操作，避免过多的无线信号引起电量消耗。</p>

<h4>传输数据格式选择</h4>

<p>1.如果是需要全局数据的，考虑使用Protobuffers(序列化反序列化性能高于Json)，并且考虑使用 nano protocol buffer。</p>

<p>2.如果传输回来的数据不需要全量读取，考虑使用 Flatbuffers (序列化反序列化几乎不耗时，耗时是在读取对象时(就这一部分如果需要优化，可以参看 Flatbuffer Use Optimize</p>

<h4>输入流</h4>

<p>使用具有缓存策略的输入流</p>

<pre><code>   原            建议替换为
InputStream    BufferedInputStream
Reader         BufferedReader
</code></pre>

<h4>数据结构</h4>

<p>如果已知大概需要多大，就直接给初始大小，减少扩容时额外开销。</p>

<p>•ArrayList :里面就一数据，内存小，有序取值快，扩容效率低。</p>

<p>•LinkedList :里面就一双向链表，内存大，随机插入删除快，扩容率高。</p>

<p>•HashSet :里面就HashMap,用key对外存储，目的就是不允许重复元素。</p>

<p>•ConcruuenHashMap :线程安全，采用细分锁，锁颗粒更小，并发性能更优.</p>

<p>•Collections.synchronizedMap : 线程安全，采用当前对象作为锁，颗粒较大，并发性能较差。</p>

<p>•SparseArray、 SparseBooleanArray、 SparseIntArray: 针对Key为 Int、 Boolean进行了优化，采用二分法查找，简单数组存储。相比 HashMap而言， HashMap每添加一个数据，大约会需要申请额外的32字节的数据，因此 Sparsexxx在内存方面的开销会小很多。</p>

<h4>编码习惯</h4>

<p>1.尽量简化，不做没必要的操作。</p>

<p>2.尽量避免分配内存（创建对象）。</p>

<p>3.如果你确定不需要访问类成员，就把方法static，这样调用速度可以提升15%~20%，因为不需要切换对象状态。</p>

<p>4.如果某个参数是常量，要加上static final ,这样可以让Class首次初始化的时候不用调用<clinit>来创建 static方法，而是在编译时就直接将常量替换代码中使用的位置。</p>

<p>5.Android开发中，类内尽量避免通过 get/set访问成员变量，虽然这在语言的开发中是一个好的习惯，但是Android虚拟机中，对方法的调用开销远大于对变量的直接访问。在没有JIT的情况下，直接的变量访问比调用方法快3倍，在JIT下，直接的变量访问更是比调用方法快7倍!</p>

<p>6.当内部类需要访问外部类的私有 方法/变量时，考虑将这些外部类的私有 方法/变量改用包可见的方式。首先在编写代码的时候，通过内部类访问外部类的私有 方法/变量是合法的，但是在编译的时候为了满足这个会将需要被内部类访问的私有 方法/变量封装一层包可见的方法，实现让内部类访问这些私有的 方法/变量，根据前面我们有提到说方法的调用开销大于变量的调用，因此这样使得性能变差，所以我们在编码的时候可以考虑直接将需要被内部类调用的外部类私有 方法/变量，改为包可见。</p>

<p>7.尽量少使用 float。在很多现代设备中， double的性能与 float的性能几乎没有差别，但是从大小上面 double是 float的两倍的大小。</p>

<p>8.尽量考虑使用整型而非浮点数，在较好的Android设备中，浮点数比整型慢一倍。</p>

<p>9.尽量不要使用除法操作，有很多处理器有乘法器，但是没有除法器，也就是说在这些设备中需要将除法分解为其他的计算方式速度会比较慢。</p>

<p>10.尽量使用系统sdk中提供的方法，而非自己去实现。如 String.indexOf()相关的API，Dalvik将会替换为内部方法； System.arraycopy()方法在Nexus One手机上，会比我们上层写的类似方法的执行速度快9倍。</p>

<p>11.谨慎编写native，性能不一定更好，Native并不是用于使得性能更好，而是用于有些已经存在的库是使用native语言实现的，我们需要引入Android，这时才使用。1) 需要多出开销在维持Java-native的通信；2) 在native中创建的资源由于在native heap上面，因此需要主动的释放；3) 需要对不同的处理器架构进行支持，存在明显的兼容性问题需要解决。</p>

<p>12.在没有JIT的设备中，面向接口编程的模式(如 Map map)，相比直接访问对象类(如 HashMap map)，会慢6%，但是在存在JIT的设备中，两者的速度差不多。但是内存占用方面面向接口变成会消耗更多内存，因此如果你的面向接口编程不是十分的必要的情况下可以考虑不用。</p>

<p>13.在没有JIT的设备中，访问本地化变量相对与成员变量会快20%，但是在存在JIT的设备中，两者速度差不多。</p>

<h4>遍历优化</h4>

<p>尽量使用 Iterable而不是通过长度判断来进行遍历。</p>

<pre><code>// 这种性能是最差的，JIT也无法对其优化。
public void zero() {
    int sum = 0;
    for (int i = 0; i &lt; mArray.length; ++i) {
        sum += mArray[i].mSplat;
    }
}
// 相对zero()来说，这种写法会更快些，在存在JIT的情况下速度几乎和two()速度一样快。
public void one() {
    int sum = 0;
    // 1) 通过本地化变量，减少查询，在不存在JIT的手机下，优化较明显。
    Foo[] localArray = mArray;
    // 2) 获取队列长度，减少每次遍历访问变量的长度，有效优化。
    int len = localArray.length;
    for (int i = 0; i &lt; len; ++i) {
        sum += localArray[i].mSplat;
    }
}
// 在无JIT的设备中，是最快的遍历方式，在存在JIT的设备中，与one()差不多快。
public void two() {
    int sum = 0;
    for (Foo a : mArray) {
        sum += a.mSplat;
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[转：Android最佳性能实践——合理管理内存]]></title>
    <link href="http://wentao1990.github.io/blog/2016/08/07/android-performs1/"/>
    <updated>2016-08-07T13:42:26+08:00</updated>
    <id>http://wentao1990.github.io/blog/2016/08/07/android-performs1</id>
    <content type="html"><![CDATA[<p>原文：<a href="http://blog.csdn.net/guolin_blog/article/details/42238627">http://blog.csdn.net/guolin_blog/article/details/42238627</a></p>

<p>注意本系列文章的内容基本源于Android Doc，如果想要阅读更加详细的关于性能方面的资料，可以直接去阅读Android官方文档。</p>

<p>内存(RAM)对于任何一个软件开发环境都是种非常珍贵的资源，而对于移动操作系统来讲的话，则会显得更加珍贵，因为手机的硬件条件相对于PC毕竟是比较落后的。尽管Android系统的虚拟机拥有自动回收垃圾的机制，但这并不代表我们就可以忽视应该在什么时候分配和释放内存。</p>

<p>为了使垃圾回收器可以正常释放程序所占用的内存，在编写代码的时候就一定要注意尽量避免出现内存泄漏的情况（通常都是由于全局成员变量持有对象引用所导致的），并且在适当的时候去释放对象引用。对于大多数的应用程序而言，后面其它的事情就可以都交给垃圾回收器去完成了，如果一个对象的引用不再被其它对象所持有，那么系统就会将这个对象所分配的内存进行回收。</p>

<p>我们在开发软件的时候应当自始至终都把内存的问题充分考虑进去，这样的话才能开发出更加高性能的软件。而内存问题也并不是无规律可行的，Android系统给我们提出了很多内存优化的建议技巧，只要按照这些技巧来编写程序，就可以让我们的程序在内存性能发面表现得相当不错，下面我们就来一一学习一下这些技巧。  <!--more--></p>

<h3>节制地使用Service</h3>

<p>如果应用程序当中需要使用Service来执行后台任务的话，请一定要注意只有当任务正在执行的时候才应该让Service运行起来。另外，当任务执行完之后去停止Service的时候，要小心Service停止失败导致内存泄漏的情况。</p>

<p>当我们启动一个Service时，系统会倾向于将这个Service所依赖的进程进行保留，这样就会导致这个进程变得非常消耗内存。并且，系统可以在LRU cache当中缓存的进程数量也会减少，导致切换应用程序的时候耗费更多性能。严重的话，甚至有可能会导致崩溃，因为系统在内存非常吃紧的时候可能已无法维护所有正在运行的Service所依赖的进程了。</p>

<p>为了能够控制Service的生命周期，Android官方推荐的最佳解决方案就是使用IntentService，这种Service的最大特点就是当后台任务执行结束后会自动停止，从而极大程度上避免了Service内存泄漏的可能性。关于IntentService更加详细的用法讲解，可以参考《第一行代码——Android》的9.5.2节。</p>

<p>让一个Service在后台一直保持运行，即使它并不执行任何工作，这是编写Android程序时最糟糕的做法之一。所以Android官方极度建议开发人员们不要过于贪婪，让Service在后台一直运行，这不仅可能会导致手机和程序的性能非常低下，而且被用户发现了之后也有可能直接导致我们的软件被卸载（我个人就会这么做）。</p>

<h3>当界面不可见时释放内存</h3>

<p>当用户打开了另外一个程序，我们的程序界面已经不再可见的时候，我们应当将所有和界面相关的资源进行释放。在这种场景下释放资源可以让系统缓存后台进程的能力显著增加，因此也会让用户体验变得更好。</p>

<p>那么我们如何才能知道程序界面是不是已经不可见了呢？其实很简单，只需要在Activity中重写onTrimMemory()方法，然后在这个方法中监听TRIM_MEMORY_UI_HIDDEN这个级别，一旦触发了之后就说明用户已经离开了我们的程序，那么此时就可以进行资源释放操作了，如下所示：</p>

<pre><code>@Override  
public void onTrimMemory(int level) {  
    super.onTrimMemory(level);  
    switch (level) {  
    case TRIM_MEMORY_UI_HIDDEN:  
        // 进行资源释放操作  
        break;  
    }  
}  
</code></pre>

<p>注意onTrimMemory()方法中的TRIM_MEMORY_UI_HIDDEN回调只有当我们程序中的所有UI组件全部不可见的时候才会触发，这和onStop()方法还是有很大区别的，因为onStop()方法只是当一个Activity完全不可见的时候就会调用，比如说用户打开了我们程序中的另一个Activity。因此，我们可以在onStop()方法中去释放一些Activity相关的资源，比如说取消网络连接或者注销广播接收器等，但是像UI相关的资源应该一直要等到onTrimMemory(TRIM_MEMORY_UI_HIDDEN)这个回调之后才去释放，这样可以保证如果用户只是从我们程序的一个Activity回到了另外一个Activity，界面相关的资源都不需要重新加载，从而提升响应速度。</p>

<h3>当内存紧张时释放内存</h3>

<p>除了刚才讲的TRIM_MEMORY_UI_HIDDEN这个回调，onTrimMemory()方法还有很多种其它类型的回调，可以在手机内存降低的时候及时通知我们。我们应该根据回调中传入的级别来去决定如何释放应用程序的资源：</p>

<h4>• TRIM_MEMORY_RUNNING_MODERATE    表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经有点低了，系统可能会开始根据LRU缓存规则来去杀死进程了。</h4>

<h4>• TRIM_MEMORY_RUNNING_LOW    表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经非常低了，我们应该去释放掉一些不必要的资源以提升系统的性能，同时这也会直接影响到我们应用程序的性能。</h4>

<h4>• TRIM_MEMORY_RUNNING_CRITICAL    表示应用程序仍然正常运行，但是系统已经根据LRU缓存规则杀掉了大部分缓存的进程了。这个时候我们应当尽可能地去释放任何不必要的资源，不然的话系统可能会继续杀掉所有缓存中的进程，并且开始杀掉一些本来应当保持运行的进程，比如说后台运行的服务。</h4>

<p>以上是当我们的应用程序正在运行时的回调，那么如果我们的程序目前是被缓存的，则会收到以下几种类型的回调：</p>

<h4>• TRIM_MEMORY_BACKGROUND    表示手机目前内存已经很低了，系统准备开始根据LRU缓存来清理进程。这个时候我们的程序在LRU缓存列表的最近位置，是不太可能被清理掉的，但这时去释放掉一些比较容易恢复的资源能够让手机的内存变得比较充足，从而让我们的程序更长时间地保留在缓存当中，这样当用户返回我们的程序时会感觉非常顺畅，而不是经历了一次重新启动的过程。</h4>

<h4>• TRIM_MEMORY_MODERATE    表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的中间位置，如果手机内存还得不到进一步释放的话，那么我们的程序就有被系统杀掉的风险了。</h4>

<h4>• TRIM_MEMORY_COMPLETE    表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的最边缘位置，系统会最优先考虑杀掉我们的应用程序，在这个时候应当尽可能地把一切可以释放的东西都进行释放。</h4>

<h3>避免在Bitmap上浪费内存</h3>

<p>当我们读取一个Bitmap图片的时候，有一点一定要注意，就是千万不要去加载不需要的分辨率。在一个很小的ImageView上显示一张高分辨率的图片不会带来任何视觉上的好处，但却会占用我们相当多宝贵的内存。需要仅记的一点是，将一张图片解析成一个Bitmap对象时所占用的内存并不是这个图片在硬盘中的大小，可能一张图片只有100k你觉得它并不大，但是读取到内存当中是按照像素点来算的，比如这张图片是1500<em>1000像素，使用的ARGB_8888颜色类型，那么每个像素点就会占用4个字节，总内存就是1500</em>1000*4字节，也就是5.7M，这个数据看起来就比较恐怖了。</p>

<pre><code>至于如何去压缩图片，以及更多在图片方面节省内存的技术，大家可以去参考我之前写的一篇博客 Android高效加载大图、多图解决方案，有效避免程序OOM 。
</code></pre>

<h3>使用优化过的数据集合</h3>

<p>Android API当中提供了一些优化过后的数据集合工具类，如SparseArray，SparseBooleanArray，以及LongSparseArray等，使用这些API可以让我们的程序更加高效。传统Java API中提供的HashMap工具类会相对比较低效，因为它需要为每一个键值对都提供一个对象入口，而SparseArray就避免掉了基本数据类型转换成对象数据类型的时间。</p>

<h3>知晓内存的开支情况</h3>

<p>我们还应当清楚我们所使用语言的内存开支和消耗情况，并且在整个软件的设计和开发当中都应该将这些信息考虑在内。可能有一些看起来无关痛痒的写法，结果却会导致很大一部分的内存开支，例如：
使用枚举通常会比使用静态常量要消耗两倍以上的内存，在Android开发当中我们应当尽可能地不使用枚举。
任何一个Java类，包括内部类、匿名类，都要占用大概500字节的内存空间。
任何一个类的实例要消耗12-16字节的内存开支，因此频繁创建实例也是会一定程序上影响内存的。
在使用HashMap时，即使你只设置了一个基本数据类型的键，比如说int，但是也会按照对象的大小来分配内存，大概是32字节，而不是4字节。因此最好的办法就是像上面所说的一样，使用优化过的数据集合。</p>

<h3>谨慎使用抽象编程</h3>

<p>许多程序员都喜欢各种使用抽象来编程，认为这是一种很好的编程习惯。当然，这一点不可否认，因为的抽象的编程方法更加面向对象，而且在代码的维护和可扩展性方面都会有所提高。但是，在Android上使用抽象会带来额外的内存开支，因为抽象的编程方法需要编写额外的代码，虽然这些代码根本执行不到，但是却也要映射到内存当中，不仅占用了更多的内存，在执行效率方面也会有所降低。当然这里我并不是提倡大家完全不使用抽象编程，而是谨慎使用抽象编程，不要认为这是一种很酷的编程方式而去肆意使用它，只在你认为有必要的情况下才去使用。</p>

<p>尽量避免使用依赖注入框架</p>

<p>现在有很多人都喜欢在Android工程当中使用依赖注入框架，比如说像Guice或者RoboGuice等，因为它们可以简化一些复杂的编码操作，比如可以将下面的一段代码：</p>

<pre><code>class AndroidWay extends Activity {   
    TextView name;   
    ImageView thumbnail;   
    LocationManager loc;   
    Drawable icon;   
    String myName;   

    public void onCreate(Bundle savedInstanceState) {   
        super.onCreate(savedInstanceState);   
        setContentView(R.layout.main);  
        name      = (TextView) findViewById(R.id.name);   
        thumbnail = (ImageView) findViewById(R.id.thumbnail);   
        loc       = (LocationManager) getSystemService(Activity.LOCATION_SERVICE);   
        icon      = getResources().getDrawable(R.drawable.icon);   
        myName    = getString(R.string.app_name);   
        name.setText( "Hello, " + myName );   
    }   
}   
</code></pre>

<p>简化成这样的一种写法：</p>

<pre><code>@ContentView(R.layout.main)  
class RoboWay extends RoboActivity {   
    @InjectView(R.id.name)             TextView name;   
    @InjectView(R.id.thumbnail)        ImageView thumbnail;   
    @InjectResource(R.drawable.icon)   Drawable icon;   
    @InjectResource(R.string.app_name) String myName;   
    @Inject                            LocationManager loc;   

    public void onCreate(Bundle savedInstanceState) {   
        super.onCreate(savedInstanceState);   
        name.setText( "Hello, " + myName );   
    }   
}  
</code></pre>

<p>看上去确实十分诱人，我们甚至可以将findViewById()这一类的繁琐操作全部省去了。但是这些框架为了要搜寻代码中的注解，通常都需要经历较长的初始化过程，并且还可能将一些你用不到的对象也一并加载到内存当中。这些用不到的对象会一直占用着内存空间，可能要过很久之后才会得到释放，相较之下，也许多敲几行看似繁琐的代码才是更好的选择。</p>

<h3>使用ProGuard简化代码</h3>

<p>ProGuard相信大家都不会陌生，很多人都会使用这个工具来混淆代码，但是除了混淆之外，它还具有压缩和优化代码的功能。ProGuard会对我们的代码进行检索，删除一些无用的代码，并且会对类、字段、方法等进行重命名，重命名之后的类、字段和方法名都会比原来简短很多，这样的话也就对内存的占用变得更少了。</p>

<h3>使用多个进程</h3>

<p>这个技巧其实并不是非常建议使用，但它确实是一种可以帮助我们节省和管理内存的高级技巧。如果你要使用它的话一定要谨慎使用，因为绝大多数的应用程序都不应该在多个进程当中运行的，一旦使用不当，它甚至会增加额外的内存而不是帮我们节省内存。这个技巧比较适用于那些需要在后台去完成一项独立的任务，和前台的功能是可以完全区分开的场景。</p>

<p>这里举一个比较适合去使用多进程技巧的场景，比如说我们正在做一个音乐播放器软件，其中播放音乐的功能应该是一个独立的功能，它不需要和UI方面有任何关系，即使软件已经关闭了也应该可以正常播放音乐。如果此时我们只使用一个进程，那么即使用户关闭了软件，已经完全由Service来控制音乐播放了，系统仍然会将许多UI方面的内存进行保留。在这种场景下就非常适合使用两个进程，一个用于UI展示，另一个则用于在后台持续地播放音乐。</p>

<p>想要实现多进程的功能也非常简单，只需要在AndroidManifest文件的应用程序组件中声明一个android:process属性就可以了，比如说我们希望播放音乐的Service可以运行在一个单独的进程当中，就可以这样写：</p>

<pre><code>&lt;service android:name=".PlaybackService"  
         android:process=":background" /&gt;  
</code></pre>

<p>这里指定的进程名是background，你也可以将它改成任意你喜欢的名字。需要注意的是，进程名的前面都应该加上一个冒号，表示该进程是一个当前应用程序的私有进程。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何快速搭建一个完整的移动直播系统？]]></title>
    <link href="http://wentao1990.github.io/blog/2016/07/19/server/"/>
    <updated>2016-07-19T22:53:30+08:00</updated>
    <id>http://wentao1990.github.io/blog/2016/07/19/server</id>
    <content type="html"><![CDATA[<p>移动直播行业的火热会在很长一段时间内持续，通过和各行业的整合，从而成为具有无限可能性的行业。主要有以下三个原因：</p>

<p>第一，移动直播的UGC生产模式比PC端的直播更明显，人人都有设备，随时随地开播，完全顺应了互联网时代的开放性原则，能刺激更多人去创造和传播优质内容。</p>

<p>第二，网络带宽和速度在逐渐提高，网络成本在逐渐下降，为移动直播提供一个极佳的发展环境。文字、声音、视频、游戏等都会在移动直播中呈现，创造出更加丰富的用户体验。 直播可以以SDK的形式接入到自己的应用中 ，比如，教育领域中的课后辅导完全可以以直播的形式开展业务、电商也可借助直播让用户挑选商品，促进销售。 <!--more--></p>

<p>第三， 一个与VR/AR技术相结合的移动直播为整个行业的未来提供了新的发展空间。 VR/AR直播能够让用户身临其境，带动主播与观众更贴近真实的互动，大大提高平台的用户参与度。</p>

<p>当下，有技术实力和流量优势的互联网从业者都不愿错过直播这个风口，如何快速搭建一个直播系统成了大家关心的问题，我想和大家分享下我的经验。我从事于一家直播产品开发商，我们的产品为了快速赶上市场，使用了云服务提供商的直播SDK。</p>

<p>从业者都知道，一个完整直播产品应该包含以下环节：推流端（采集、前处理、编码、推流）、服务端处理（转码、录制、截图、鉴黄）、播放器（拉流、解码、渲染）、互动系统（聊天室、礼物系统、赞）。 下面我就一一讲述下直播SDK在各个环节所做的工作。</p>

<h3>一、移动直播推流端需要做哪些工作？</h3>

<p>直播推流端即主播端，主要通过手机摄像头采集视频数据和麦克风采集音频数据，经过一系列前处理、编码、封装，然后推流到CDN进行分发。
<img src="http://i.imgur.com/xzp325c.jpg" alt="" /></p>

<h4>1、采集</h4>

<p>移动直播SDK通过手机摄像头和麦克风直接采集音视频数据。其中，视频采样数据一般采用RGB或YUV格式、音频采样数据一般采用PCM格式。采集到的原始音视频的体积是非常大的，需要经过压缩技术处理来提高传输效率。</p>

<h4>2、前处理</h4>

<p>在这个环节主要处理美颜、水印、模糊等效果。美颜功能几乎是直播的标配功能。我们调研中发现太多case是因为没有美颜功能被抛弃使用的。另外国家明确提出了，所有直播都必须打有水印并回放留存15天以上。</p>

<p>美颜实际上是通过算法去识别图像中的皮肤部分，对皮肤区域进行色值调整。 通过颜色对比找到皮肤区域，可以进行色值调整、添加白色图层或调整透明度等来达到美白效果。在美颜处理方面，最著名的GPUImage提供了丰富的效果，同时可以支持iOS和Android，支持自己写算法实现自己最理想的效果。GPUImage内置了120多种常见滤镜效果，添加滤镜只需要简单调用几行代码就可以了。</p>

<h4>3、编码</h4>

<p>为了便于手机视频的推流、拉流以及存储，通常采用视频编码压缩技术来减少视频的体积，现在比较常用的视频编码是H.264。在音频方面，比较常用的是AAC编码格式，其它如MP3、WMA也是可选方案。视频经过编码压缩大大提高了视频的存储和传输效率，当然，经过压缩后的视频在播放时必须进行解码。</p>

<p>相较于之前的H.264，2012年诞生的H.265编解码标准有了相当大的改善，做到了仅需要原来一半带宽即可播放相同质量的视频，低于1.5Mbps的网络也能传输1080p的高清视频。像阿里云、金山云都在推自己的H.265编解码技术，随着直播的快速发展和对带宽的依赖，H.265编解码技术已有全面取代H.264的趋势。</p>

<p>H264和H265个模块技术差异：
<img src="http://i.imgur.com/f2WDB3V.jpg" alt="" />
另外，硬件编码已经成为移动直播的首选方案，软编码处理在720p以上的视频颓势非常明显 。在iOS平台上硬件编码的兼容性比较好，可以直接采用，但在Android平台上，Media Codec编码器针对不同的芯片平台表现差异还是非常大的，要完全实现全平台兼容的成本还是非常高的。</p>

<h4>4、推流</h4>

<p>要想用于推流还必须把音视频数据使用传输协议进行封装，变成流数据。 常用的流传输协议有RTSP、RTMP、HLS等，使用RTMP传输的延时通常在1–3秒，对于移动直播这种实时性要求非常高的场景，RTMP也成为移动直播中最常用的流传输协议。最后通过一定的Qos算法将音视频流数据推送到网络断，通过CDN进行分发。在直播场景中，网络不稳定是非常常见的，这时就需要Qos来保证网络不稳情况下的用户观看直播的体验，通常是通过主播端和播放端设置缓存，让码率均匀。另外，针对实时变化的网络状况，动态码率和帧率也是最常用的策略。</p>

<p>当然，在网络传输方面全部自己来做基本不现实，找提供推流服务的CDN服务商提供解决方案是最好的选择。据了解，阿里云是国内唯一能自研CDN缓存服务器的厂商，性能非常有保障。当然，大多数直播平台都会同时接入多个视频云服务提供商，这样可以做拉流线路互备，对推流后视频集群再进行优化也可提高直播的流畅性和稳定性。</p>

<h3>二、服务端处理需要做哪些工作？</h3>

<p>要想适配各终端和平台，服务端还需要对流进行转码，如支持RTMP、HLS、FLV等格式拉流，支持一路转多路适配不同网络和分辨率的终端设备。</p>

<h4>1、截图、录制、水印</h4>

<p>像阿里云等云服务商都提供了实时转码技术，将用户推流码率较高（比如720P）实时转化成较低清晰度（比如360P）的流以适应播放端的需求。如果要自己搭建实时转码系统，这个成本是极高的，一台8核设备只能实时转10路流，如果一个正常的直播平台有1000路流，就需要100台设备，加上后期的运维成本，一般公司就吃不消了。</p>

<h4>2、鉴黄</h4>

<p>2016年4月14日，文化部查出了斗鱼、虎牙、YY、熊猫TV、六间房、9158等涉嫌提供含宣扬淫秽、暴力、教唆犯罪的网络直播平台，被列入查处名单。政府介入管制有利于直播行业打造健康的生态，进入良性发展。这也意味着为了安全直播产品鉴黄成了必需环节，使用技术手段去鉴黄是移动直播平台必然采用的方案。</p>

<p>市面上提供鉴黄服务的方案主要有两种：</p>

<p>第一种是对视频进行截图，然后对图片进行鉴黄，返回鉴黄结果和分值。 典型的企业有阿里（绿网）、图谱科技，他们目前都支持直接传入视频，经过服务端分析返回结果。通常由业务系统接入鉴黄服务，根据鉴黄结果对直播流进行控制，如切断直播流、封禁账号等。</p>

<p>第二种是和CDN结合，直接对直播流进行分析，识别结果分为色情、疑似色情、性感和正常，业务系统根据识别结果直接控制直播流。 典型的企业是Viscovery，这套方案的优点是实时性保证比较好，缺点是必须部署到CDN或自己的机房，使用成本相对高一些。</p>

<p>还有一种一站式直播解决方案提供商，他们的做法是，用户只需在控制台对鉴黄服务进行配置就可以针对每个应用、每一路直播流进行实时审核。在控制台中，云服务商实时将鉴黄结果返回，用户可以直接查看色情直播和违规界面的截图，同时可以对直播流进行控制，切断问题直播流。该服务商还提供了短信、邮件和站内信功能，避免漏掉任何一个非法视频，给平台造成损失，我们就使用了这种方式。
<img src="http://i.imgur.com/wKXx4p9.jpg" alt="" /></p>

<h3>三、播放器端需要做哪些工作？</h3>

<p>在播放器端如何做到秒开，直播过程中保证画面和声音清晰度的同时，稳定、流程、无卡顿的直播流量，这些工作都需要播放器端配合服务端来做优化，做到精确调度。</p>

<h4>1、拉流</h4>

<p>拉流实际是推流的逆过程。首先通过播放端获取码流，标准的拉流格式有RTMP、HLS、FLV等。RTMP是Adobe的专利协议，开源软件和开源库都支持的比较好，如开源的librtmp库，播放端只要支持flashPlayer的就能非常简单的播放RTMP直播，直播延迟一般在1–3秒。</p>

<p>HLS是苹果提出的基于HTTP的流媒体传输协议，HTML5可以直接打开播放，通过微信、QQ等软件分享出去，用户也可以直接观看直播，可以说移动直播app，HLS拉流协议是必须支持的，缺点是延迟通常大于10秒。FLV（HTTP-FLV）协议是使用HTTP协议传输流媒体内容的一个协议，也不用担心被Adobe的专利绑架，直播延迟同样可以做到1–3秒。</p>

<p>各拉流协议的差异：</p>

<p>我们使用的云服务的直播拉流技术提供了以上三种格式，满足不同业务场景的需求，如对即时性要求较高或有互动需求的可以采用RTMP或FLV格式进行直播拉流播放；对于有回放或跨平台需求的，推荐使用HLS。当然，三种协议是可以同时使用的，分别用到自己的场景就可以了。</p>

<h4>2、解码和渲染</h4>

<p>拉流获取封装的视频数据后，必须通过解码器解码、渲染后才能在播放器上播放。它是编码的逆过程，是指从音视频的数据中提取原始数据。前面介绍的H.264和H.265编码格式都是有损压缩，所以在提取后的原始数据，并非原始采样数据，存在一定的信息丢失。因此，在视频体积最小的情况下通过各种编码参数保留最好的原始画面，成为了各视频公司的核心机密。</p>

<p>考虑对高清的支持，解码肯定还是要选择硬解码的。前面介绍过，iOS系统由于硬件比较单一、比较封闭，支持的比较好，Android系统由于平台差异非常大，编解码要完全兼容各平台还需要很多工作要做。</p>

<p>四、移动直播中的交互系统</p>

<p>移动直播中最常见的交互有聊天室（弹幕）、点赞、打赏和礼物等，交互系统涉及消息的实时性和互动性，在技术实现上大多是使用IM的功能来实现的。对于在线人数比较多的房间，弹幕消息量是非常大，主播与用户其实都看不过来，为了缓解服务器压力，在产品策略需要做一些必要的优化。</p>

<p>1、聊天室</p>

<p>移动直播中的弹幕交互是用户和主播互动的主要方式，实际上就是IM中的聊天室功能。聊天室和群聊功能类似，但聊天室的消息是不需要分发给不在线的用户的，历史消息也不需要查看，用户只有进入聊天室后才能查看聊天消息和群成员信息。面对复杂多变的网络状况，还需要根据用户位置就近选择近对应运营商的单线机房接入弹幕消息服务，让弹幕更及时。</p>

<p>2、礼物系统</p>

<p>礼物系统更是绝大多数移动直播平台的标配了，它是这些平台主要的收入来源。送礼物的形式也增强了用户和主播之间的互动交流，也是主播依赖平台的最主要原因。</p>

<p>礼物的收发在技术实现上也是用聊天室接口做的，通常采用IM中的自定义消息实现，当用户收到或发送礼物时将自定义消息对应的礼物图形渲染出来。</p>

<p>原文出处：<a href="http://www.leiphone.com/news/201607/Nhq9iveY5y5fQ3Gw.html">http://www.leiphone.com/news/201607/Nhq9iveY5y5fQ3Gw.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Service与 IntentService 的区别与使用场景]]></title>
    <link href="http://wentao1990.github.io/blog/2016/05/23/android-server/"/>
    <updated>2016-05-23T17:50:35+08:00</updated>
    <id>http://wentao1990.github.io/blog/2016/05/23/android-server</id>
    <content type="html"><![CDATA[<h4>1.IntentService是继承自Service的</h4>

<h4>2.Service不是一个单独的进程 ，它和应用程序在同一个进程中。</h4>

<h4>3.Service不是一个线程，所以我们应该避免在Service里面进行耗时的操作</h4>

<h4>4.IntentService相对于Service来说，有几个非常有用的优点</h4>

<p>IntentService使用队列的方式将请求的Intent加入队列，然后开启一个worker thread(线程)来处理队列中的Intent，对于异步的startService请求，IntentService会处理完成一个之后再处理第二个，每一个请求都会在一个单独的worker thread中处理，不会阻塞应用程序的主线程，这里就给我们提供了一个思路，如果有耗时的操作与其在Service里面开启新线程还不如使用IntentService来处理耗时操作。 <!--more--></p>

<p>因为最大部分的service不需要同时处理多个请求(处理多个请求是一个比较危险的多线程的场景),这样在在这种情况下呢，最好使用IntentService类如果你实现你的服务。</p>

<p>使用intentService与service有什么不同呢</p>

<h4>a . 直接 创建一个默认的工作线程,该线程执行所有的intent传递给onStartCommand()区别于应用程序的主线程。</h4>

<h4>b . 直接创建一个工作队列,将一个意图传递给你onHandleIntent()的实现,所以我们就永远不必担心多线程。</h4>

<h4>c . 当请求完成后自己会调用stopSelf()，所以你就不用调用该方法了。</h4>

<h4>d . 提供的默认实现onBind()返回null，所以也不需要重写这个方法。so easy啊</h4>

<h4>e . 提供了一个默认实现onStartCommand(),将意图工作队列,然后发送到你onHandleIntent()实现。真是太方便了</h4>

<p>我们需要做的就是实现onHandlerIntent()方法，还有一点就是经常被遗忘的，构造函数是必需的,而且必须调用超IntentService(字符串) ，因为工作线程的构造函数必须使用一个名称。如何实现呢，我们借助于谷歌官方文档来看一下吧。</p>

<pre><code>public class HelloIntentService extends IntentService {  

  /** 
   * A constructor is required, and must call the super IntentService(String) 
   * constructor with a name for the worker thread. 
   */  
  public HelloIntentService() {  
      super("HelloIntentService");  
  }  

  /** 
   * The IntentService calls this method from the default worker thread with 
   * the intent that started the service. When this method returns, IntentService 
   * stops the service, as appropriate. 
   */  
  @Override  
  protected void onHandleIntent(Intent intent) {  
      // Normally we would do some work here, like download a file.  
      // For our sample, we just sleep for 5 seconds.  
      long endTime = System.currentTimeMillis() + 5*1000;  
      while (System.currentTimeMillis() &lt; endTime) {  
          synchronized (this) {  
              try {  
                  wait(endTime - System.currentTimeMillis());  
              } catch (Exception e) {  
              }  
          }  
      }  
  }  
}  
</code></pre>

<p>那么它为什么不用stopself()方法呢，我们看一下自身的源代码吧</p>

<pre><code>    public abstract class IntentService extends Service {  
    private volatile Looper mServiceLooper;  
    private volatile ServiceHandler mServiceHandler;  
    private String mName;  
    private boolean mRedelivery;  

    private final class ServiceHandler extends Handler {  
        public ServiceHandler(Looper looper) {  
            super(looper);  
        }  

        @Override  
        public void handleMessage(Message msg) {  
            onHandleIntent((Intent)msg.obj);  
            stopSelf(msg.arg1);  
        }  
    }  

    /** 
     * Creates an IntentService.  Invoked by your subclass's constructor. 
     * 
     * @param name Used to name the worker thread, important only for debugging. 
     */  
    public IntentService(String name) {  
        super();  
        mName = name;  
    }  

    /** 
     * Sets intent redelivery preferences.  Usually called from the constructor 
     * with your preferred semantics. 
     * 
     * &lt;p&gt;If enabled is true, 
     * {@link #onStartCommand(Intent, int, int)} will return 
     * {@link Service#START_REDELIVER_INTENT}, so if this process dies before 
     * {@link #onHandleIntent(Intent)} returns, the process will be restarted 
     * and the intent redelivered.  If multiple Intents have been sent, only 
     * the most recent one is guaranteed to be redelivered. 
     * 
     * &lt;p&gt;If enabled is false (the default), 
     * {@link #onStartCommand(Intent, int, int)} will return 
     * {@link Service#START_NOT_STICKY}, and if the process dies, the Intent 
     * dies along with it. 
     */  
    public void setIntentRedelivery(boolean enabled) {  
        mRedelivery = enabled;  
    }  

    @Override  
    public void onCreate() {  
        // TODO: It would be nice to have an option to hold a partial wakelock  
        // during processing, and to have a static startService(Context, Intent)  
        // method that would launch the service &amp; hand off a wakelock.  

        super.onCreate();  
        HandlerThread thread = new HandlerThread("IntentService[" + mName + "]");  
        thread.start();  

        mServiceLooper = thread.getLooper();  
        mServiceHandler = new ServiceHandler(mServiceLooper);  
    }  

    @Override  
    public void onStart(Intent intent, int startId) {  
        Message msg = mServiceHandler.obtainMessage();  
        msg.arg1 = startId;  
        msg.obj = intent;  
        mServiceHandler.sendMessage(msg);  
    }  

    /** 
     * You should not override this method for your IntentService. Instead, 
     * override {@link #onHandleIntent}, which the system calls when the IntentService 
     * receives a start request. 
     * @see android.app.Service#onStartCommand 
     */  
    @Override  
    public int onStartCommand(Intent intent, int flags, int startId) {  
        onStart(intent, startId);  
        return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;  
    }  

    @Override  
    public void onDestroy() {  
        mServiceLooper.quit();  
    }  

    /** 
     * Unless you provide binding for your service, you don't need to implement this 
     * method, because the default implementation returns null.  
     * @see android.app.Service#onBind 
     */  
    @Override  
    public IBinder onBind(Intent intent) {  
        return null;  
    }  

    /** 
     * This method is invoked on the worker thread with a request to process. 
     * Only one Intent is processed at a time, but the processing happens on a 
     * worker thread that runs independently from other application logic. 
     * So, if this code takes a long time, it will hold up other requests to 
     * the same IntentService, but it will not hold up anything else. 
     * When all requests have been handled, the IntentService stops itself, 
     * so you should not call {@link #stopSelf}. 
     * 
     * @param intent The value passed to {@link 
     *               android.content.Context#startService(Intent)}. 
     */  
    protected abstract void onHandleIntent(Intent intent);  
}  
</code></pre>

<p>我们可以看到源代码里头的第15行handlerMessage方法里当处理完请求后就会调用stopself()方法了，外界就不用调用了，此外还有一点我们可以看到代码最后一行第110行，onhandleIntent()是一个抽象类，而其他类都是抽象类，所以我们就可以理解为什么只需要重写onhandleIntent()方法了吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义任意形状的ImageView]]></title>
    <link href="http://wentao1990.github.io/blog/2016/04/08/android-imageview/"/>
    <updated>2016-04-08T22:22:25+08:00</updated>
    <id>http://wentao1990.github.io/blog/2016/04/08/android-imageview</id>
    <content type="html"><![CDATA[<h4>参考</h4>

<p>Xfermode in android - 解释文档和模式部分写得很好
Android中Canvas绘图之PorterDuffXfermode使用及工作原理详解 - 代码实践分析部分值得细看</p>

<p>网上大部分文章都说有3个类可用, 但是实际上仅需要掌握PoterDuffXfermode, 因为只有它支持硬件加速, 官方的文档的描述中Xfermode的直接继承类也只有它了, 所以一般只用它.</p>

<p>PoterDuffXfermode</p>

<p>Porter-Duff 操作是 1 组 12 项用于描述数字图像合成的基本手法，包括Clear、Source Only、Destination Only、Source Over、Source In、SourceOut、Source Atop、Destination Over、Destination In、DestinationOut、Destination Atop、XOR。通过组合使用 Porter-Duff 操作，可完成任意 2D图像的合成。Thomas Porter 和 Tom Duff 发表于 1984年原始论文的扫描版本
简单来说就是一种图像合成的理论依据, 规定了合成图像时的像素操作. Android中支持总共18种模式, 就不一一列举了. 看懂文档就行.</p>

<!--more-->


<h3>文档解释</h3>

<pre><code>public enum Mode { 
    // ... 
    /** [Sa + (1 - Sa)*Da, Dc + (1 - Da)*Sc] */ 
    DST_OVER (4), 
    /** [Sa * Da, Sa * Dc] */ 
    DST_IN (6), 
    // ...以下省略
}
</code></pre>

<p>文档中每个模式对应一条公式, 公式中的缩写表示:
SRC = source, 表示即将要画的像素
DST = destination, 表示已经存在的像素
Sa = Source alpha, 透明通道值
Da = Dest alpha
Sc = Source color, 颜色值
Dc = Dst color
[AlphaValue, ColorValue] -> 第一个值为进行像素操作后的透明通道值, 第二个值为操作后的颜色值</p>

<h4>举个例子:</h4>

<p>DST_IN - [Sa Da, Sa Dc]
为了简化分析, 假设透明通道值不是0就是1
主要看颜色值的计算 Sa * Dc, 当Sa = 1的时候, 颜色值就是Dc, 也就是说在准备画的像素的alpha值为1的地方, 直接显示原来的像素, Sa = 0的时候不显示任何颜色, 并且只有在Sa和Da都是1的地方才会显示颜色.</p>

<p>加入透明通道值的分析参考Xfermode in android</p>

<p>看懂文档后我们就可以利用Xfermode做各种图形效果, Xfermode可以做的事情理论上</p>

<p>可完成任意 2D图像的合成
远远不限于实现任意形状的ImageView. 接下来就一步步分析如下实现任意形状的ImageView和我遇到的问题.</p>

<p>实现任意形状ImageView</p>

<p>分析</p>

<p>为了最简化代码, 最好能够复用ImageView, 而ImageView#onDraw就是把图片画在屏幕上, 也就是说经过ImageView#onDraw方法后, 图片像素会变成DST(已经存在的像素).</p>

<p>所以要实现任意形状最直接的办法应该是根据形状裁剪图片像素, 即显示DST和SRC重合的部分的DST像素, 形状内的像素自然是SRC(即将要画的像素), 转化成公式应该是Sa * Dc, 查模式说明文档找到我们需要的模式DST_IN - [Sa * Da, Sa * Dc]</p>

<p>所以我们的核心代码应该如下</p>

<pre><code>super.onDraw(canvas);// 画图片
mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));// 设置Xfermode模式
canvas.drawXX();// 画多边形覆盖在图片上
</code></pre>

<p>使用saveLayer</p>

<p>在实际测试的时候会发现, 多边形外的像素会变成黑色(也有可能是白色), 这是因为默认情况画布只有一个图层(就是Photoshop里面的图层概念), 此时的DST不仅是图片, 还包括图片后面的背景像素, 如果清除了多边形外的像素, 当然背景也会被清除掉了, 而一般情况下我们仅需要处理图片本身, 所以实际使用中通常会使用Canvas#saveLayer来创建新的透明图层来进行图像合成的操作, 此时背景的像素就不会被纳入DST中.</p>

<p>核心代码变成</p>

<pre><code>int layerId = canvas.saveLayer(0, 0, canvas.getWidth(), canvas.getHeight(), null, Canvas.ALL_SAVE_FLAG);// 新增透明图层
super.onDraw(canvas);// 画图片
mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));// 设置Xfermode模式
canvas.drawXX();// 画多边形覆盖在图片上
canvas.restoreToCount(layerId);// 合并图层
</code></pre>

<h4>使用Bitmap</h4>

<p>如果我想制作圆形图片, 那么直接通过Canvas#drawCircle画圆, 实际运行就会发现结果跟预测的不同, 圆形外的像素并没有消失, 为什么?</p>

<p>这是因为直接通过Canvas#drawXX方法画图时, SRC仅是图形内的像素, 例如你画了一个圆, 那么SRC(即将要画的像素)仅是圆内的像素, 也就是说图片与圆不重叠的像素并不会有任何变化, 当然就不会消失了.
所以要想圆形外的像素会消失, 我们要把圆形外的像素也纳入SRC并且使其透明通道值为0.</p>

<p>所以进行"过滤"操作的时候, 例如DST_IN, 仅显示即将要画的像素一般会先创建一个Bitmap实例, 并先在Bitmap画要保留的图形, 然后再把Bitmap画在图片上, 此时SRC的像素包括了整个Bitmap而不仅仅是图形内的像素</p>

<p>.假设我们要制作的是菱形的图片, 那么代码就变成</p>

<pre><code>    // 创建一个跟图片一样大小的Bitmap, 并画一个旋转了45度的正方形
private Bitmap createMask() { 
    int maskWidth = getMeasuredWidth(); 
    int maskHeight = getMeasuredHeight(); 
    Bitmap mask = Bitmap.createBitmap(maskWidth, maskHeight, Bitmap.Config.ALPHA_8); 
    Canvas canvas = new Canvas(mask); 
    canvas.translate(maskWidth / 2, 0); 
    canvas.rotate(45); 
    int rectSize = (int) (maskWidth / 2 / Math.sin(Math.toRadians(45))); 
    canvas.drawRect(0, 0, rectSize, rectSize, mPaint);
}

// 核心操作
int layerId = canvas.saveLayer(0, 0, canvas.getWidth(), canvas.getHeight(), null, Canvas.ALL_SAVE_FLAG);// 新增透明图层
super.onDraw(canvas);// 画图片
mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));// 设置Xfermode模式
canvas.drawBitmap(createMask(), 0, 0, mPaint);// 画多边形覆盖在图片上
canvas.restoreToCount(layerId);
</code></pre>

<p>这里有个小技巧, 在创建Bitmap的时候使用了Bitmap.Config.ALPHA_8, 这是因为DST_IN的公式中仅使用了Sa, 不需要有颜色, 所以只使用ALPHA_8就足够了, 可以节省内存.</p>

<p>效果图</p>

<p><img src="http://i.imgur.com/WF3dwTc.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IP/TCP/UDP/HTTP浅谈]]></title>
    <link href="http://wentao1990.github.io/blog/2016/01/11/android-iptcphttp/"/>
    <updated>2016-01-11T18:46:25+08:00</updated>
    <id>http://wentao1990.github.io/blog/2016/01/11/android-iptcphttp</id>
    <content type="html"><![CDATA[<h4>前言：</h4>

<p>在世界上各地，各种各样的电脑运行着各自不同的操作系统为大家服务，这些电脑在表达同一种信息的时候所使用的方法是千差万别。就好像圣经中上帝打乱了各地人的口音，让他们无法合作一样。计算机使用者意识到，计算机只是单兵作战并不会发挥太大的作用。只有把它们联合起来，电脑才会发挥出它最大的潜力。于是人们就想方设法的用电线把电脑连接到了一起。但是简单的连到一起是远远不够的，就好像语言不同的两个人互相见了面，完全不能交流信息。因而他们需要定义一些共通的东西来进行交流，TCP/IP就是为此而生。TCP/IP不是一个协议，而是一个协议族的统称。里面包括了IP协议，IMCP协议，TCP协议，以及我们更加熟悉的http、ftp、pop3协议等等。电脑有了这些，就好像学会了外语一样，就可以和其他的计算机终端做自由的交流了。  <!--more--></p>

<h4>协议分层：</h4>

<p>提到协议分层，我们很容易联想到ISO-OSI的七层协议经典架构，但是TCP/IP协议族的结构则稍有不同。</p>

<p>如图所示：</p>

<p><img src="http://i.imgur.com/FFdYFsO.jpg" alt="" /></p>

<p>TCP/IP协议族按照层次由上到下，层层包装。</p>

<p>第一层：应用层，这里面有http、ftp等协议。</p>

<p>第二层：传输层，这里面有TCP和UDP等协议。</p>

<p>第三层：网络层，IP协议就在这里，它负责对数据加上IP地址和其他数据，以确定传输目标。</p>

<p>第四层:数据链路层,这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。（1.为IP模块发送和 接收IP数据报。2.为ARP模块发送ARP请求和接收ARP应答。3.为RARP发送RARP请 求和接收RARP应答）。</p>

<p>第五层：物理层，负责网络的传输，这个层次的定义包括网线的制式，网卡的定义等等。注：有些书籍并不把这层归纳在TCP/IP协议族中。</p>

<h3>IP协议</h3>

<p>IP协议是TCP/IP协议的核心，所有的TCP，UDP，IMCP，IGCP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制&ndash;这被认为是上层协议&ndash;TCP或UDP要做的事情。所以这也就出现了TCP是一个可靠的协议，而UDP就没有那么可靠的区别。</p>

<h3>TCP协议</h3>

<p>1.是面向连接的。应用程序在使用TCP协议时，必须进行连接；当然，数据传输结束后，要断开TCP连接。</p>

<p>2.TCP连接是点对点的。</p>

<p>3.TCP连接时可靠的。也就是说传输的数据时无差错的、不丢失、不重复、有序到达的。</p>

<p>4.是全双工的。即TCP连接的两端都设有发送缓存和接收缓存，用来存放双向通信的数据。</p>

<p>5.是面向字节流的。也就是说TCP将应用程序交下来的数据看成仅仅是一连串的无结构的字节流，其不知道这些字节流的具体含义。TCP议无法保证发送的数据块的具体大小，因为TCP协议的发送的数据大小收到对方给出的窗口值和当前的网络拥塞度的影响。</p>

<p>TCP的连接端点是套接字。套接字是IP地址拼接上端口号组成的，即点分方式的十进制后面是端口号，中间用逗号或冒号隔开。如下方式：
套接字Socket=(IP地址：端口号)</p>

<h4>TCP协议应用场景：</h4>

<p>TCP一般用于那些对于数据严谨准确率高但同时非紧急实时性的场景，比如：文件传输（FTP HTTP 对数据准确性要求高，速度可以相对慢）、发送或接收邮件（POP IMAP SMTP 对数据准确性要求高，非紧急应用）、远程登录（TELNET SSH 对数据准确性有一定要求，有连接的概念）等等。</p>

<h3>UDP协议</h3>

<p>UDP本身是一种不可靠的协议，UDP协议在IP协议上增加了复用、分用和差错检测功能。</p>

<p>1.是无连接的。相比于TCP协议，UDP协议在传送数据前不需要建立连接，当然也就没有释放连接。</p>

<p>2.是尽最大努力交付的。也就是说UDP协议无法保证数据能够准确的交付到目的主机。也不需要对接收到的UDP报文进行确认。</p>

<p>3.是面向报文的。也就是说UDP协议将应用层传输下来的数据封装在一个UDP包中，不进行拆分或合并。因此，运输层在收到对方的UDP包后，会去掉首部后，将数据原封不动的交给应用进程。</p>

<p>4.没有拥塞控制。因此UDP协议的发送速率不送网络的拥塞度影响。</p>

<p>5.UDP支持一对一、一对多、多对一和多对多的交互通信。</p>

<p>6.UDP的头部占用较小，只占用8个字节。</p>

<h4>UDP协议应用场景：</h4>

<p>UDP协议一般应用与那些对于数据不是很严谨高准确率但对速度实时性较高的场景，比如：即时通信（QQ聊天 对数据准确性和丢包要求比较低，但速度必须快），在线视频（RTSP 速度一定要快，保证视频连续，但是偶尔花了一个图像帧，人们还是能接受的），网络语音电话、视频会议（VoIP 语音数据包一般比较小，需要高速发送，偶尔断音或串音也没有问题）等等。</p>

<h3>HTTP协议</h3>

<p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。</p>

<p>1.支持客户/服务器模式。</p>

<p>2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>

<p>3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p>

<p>4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>

<p>5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>

<h4>HTTP应用场景：</h4>

<p>Http请求主要有http协议，基于http协议的soap协议，常见的http数据请求方式有get和post，web服务</p>

<p>优点：</p>

<p>1.基于应用级的接口使用方便</p>

<p>2.要求的开发水平不高，容错性强</p>

<p>缺点：</p>

<p>1.传输速度慢，数据包大。</p>

<p>2.如实现实时交互，服务器性能压力大</p>

<p>3.数据传输安全性差</p>

<h4>HTTP常用状态码：</h4>

<p>206 - 断点下载时用到，客户端请求了一部分内容，服务器成功把这部分内容返回给它，这时候就是用这个状态。</p>

<p>301 - 永久跳转，原地址不存在了，url被指向到另一个地址。这个主要是搜索引擎相关，影响爬虫的检索行为。</p>

<p>302 - 临时跳转，服务器会返回一个新的url给客户端，客户端可以继续访问这个url来获取内容。</p>

<p>304 - 资源没有改变，客户端可以使用本地缓存的内容，常见于静态内容访问。</p>

<p>413 - 请求实体太大。常见的情况是上传大文件，但超出了服务器(比如nginx)限制。或者请求头或请求体超出了后端的server(比如tomcat)的设置（比如当前域名下cookie太多，超出了请求头限制）</p>

<p>416 - 跟断点续传有关，客户端请求的范围超出了服务器上文件大小。</p>

<p>500 - 服务器内部错误，不能返回正常的结果。比如最常见的应用抛出空指针异常未进行处理。</p>

<p>502 - 网关错误。常见的情况是反向代理后端的服务器(比如resin或tomcat)没有启动。</p>

<p>503 - 服务不可用。比如服务器负载太高或者服务器已经停止服务。</p>

<p>504 - 网关超时。比如请求时长超出了服务器的响应时间限制。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Image]]></title>
    <link href="http://wentao1990.github.io/blog/2015/11/02/android-image/"/>
    <updated>2015-11-02T00:00:00+08:00</updated>
    <id>http://wentao1990.github.io/blog/2015/11/02/android-image</id>
    <content type="html"><![CDATA[<blockquote><hr />

<p>layout: post
title: &ldquo;&lt;转>Android高效加载大图、多图解决方案，有效避免程序OOM&rdquo;
date: 2015-11-02 16:46:35 +0800
comments: true</p>

<h2>categories: android</h2></blockquote>

<p>原文：<a href="http://blog.csdn.net/guolin_blog/article/details/9316683">http://blog.csdn.net/guolin_blog/article/details/9316683</a></p>

<p>本篇文章主要内容来自于Android Doc，我翻译之后又做了些加工，英文好的朋友也可以直接去读原文。</p>

<p><a href="http://developer.android.com/training/displaying-bitmaps/index.html">http://developer.android.com/training/displaying-bitmaps/index.html</a></p>

<h4>高效加载大图片</h4>

<p>我们在编写Android程序的时候经常要用到许多图片，不同图片总是会有不同的形状、不同的大小，但在大多数情况下，这些图片都会大于我们程序所需要的大小。比如说系统图片库里展示的图片大都是用手机摄像头拍出来的，这些图片的分辨率会比我们手机屏幕的分辨率高得多。大家应该知道，我们编写的应用程序都是有一定内存限制的，程序占用了过高的内存就容易出现OOM(OutOfMemory)异常。我们可以通过下面的代码看出每个应用程序最高可用内存是多少。  <!--more--></p>

<pre><code>int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);  
Log.d("TAG", "Max memory is " + maxMemory + "KB");  
</code></pre>

<p>因此在展示高分辨率图片的时候，最好先将图片进行压缩。压缩后的图片大小应该和用来展示它的控件大小相近，在一个很小的ImageView上显示一张超大的图片不会带来任何视觉上的好处，但却会占用我们相当多宝贵的内存，而且在性能上还可能会带来负面影响。下面我们就来看一看，如何对一张大图片进行适当的压缩，让它能够以最佳大小显示的同时，还能防止OOM的出现。</p>

<p>BitmapFactory这个类提供了多个解析方法(decodeByteArray, decodeFile, decodeResource等)用于创建Bitmap对象，我们应该根据图片的来源选择合适的方法。比如SD卡中的图片可以使用decodeFile方法，网络上的图片可以使用decodeStream方法，资源文件中的图片可以使用decodeResource方法。这些方法会尝试为已经构建的bitmap分配内存，这时就会很容易导致OOM出现。为此每一种解析方法都提供了一个可选的BitmapFactory.Options参数，将这个参数的inJustDecodeBounds属性设置为true就可以让解析方法禁止为bitmap分配内存，返回值也不再是一个Bitmap对象，而是null。虽然Bitmap是null了，但是BitmapFactory.Options的outWidth、outHeight和outMimeType属性都会被赋值。这个技巧让我们可以在加载图片之前就获取到图片的长宽值和MIME类型，从而根据情况对图片进行压缩。如下代码所示：</p>

<pre><code>BitmapFactory.Options options = new BitmapFactory.Options();  
options.inJustDecodeBounds = true;  
BitmapFactory.decodeResource(getResources(), R.id.myimage, options);  
int imageHeight = options.outHeight;  
int imageWidth = options.outWidth;  
String imageType = options.outMimeType;
</code></pre>

<p>为了避免OOM异常，最好在解析每张图片的时候都先检查一下图片的大小，除非你非常信任图片的来源，保证这些图片都不会超出你程序的可用内存。</p>

<p>现在图片的大小已经知道了，我们就可以决定是把整张图片加载到内存中还是加载一个压缩版的图片到内存中。以下几个因素是我们需要考虑的：</p>

<h5>• 预估一下加载整张图片所需占用的内存。</h5>

<h5>• 为了加载这一张图片你所愿意提供多少内存。</h5>

<h5>• 用于展示这张图片的控件的实际大小。</h5>

<h5>• 当前设备的屏幕尺寸和分辨率。</h5>

<p>比如，你的ImageView只有128<em>96像素的大小，只是为了显示一张缩略图，这时候把一张1024</em>768像素的图片完全加载到内存中显然是不值得的。</p>

<p>那我们怎样才能对图片进行压缩呢？通过设置BitmapFactory.Options中inSampleSize的值就可以实现。比如我们有一张2048<em>1536像素的图片，将inSampleSize的值设置为4，就可以把这张图片压缩成512</em>384像素。原本加载这张图片需要占用13M的内存，压缩后就只需要占用0.75M了(假设图片是ARGB_8888类型，即每个像素点占用4个字节)。下面的方法可以根据传入的宽和高，计算出合适的inSampleSize值：</p>

<pre><code>    public static int calculateInSampleSize(BitmapFactory.Options options,  
        int reqWidth, int reqHeight) {  
    // 源图片的高度和宽度  
    final int height = options.outHeight;  
    final int width = options.outWidth;  
    int inSampleSize = 1;  
    if (height &gt; reqHeight || width &gt; reqWidth) {  
        // 计算出实际宽高和目标宽高的比率  
        final int heightRatio = Math.round((float) height / (float) reqHeight);  
        final int widthRatio = Math.round((float) width / (float) reqWidth);  
        // 选择宽和高中最小的比率作为inSampleSize的值，这样可以保证最终图片的宽和高  
        // 一定都会大于等于目标的宽和高。  
        inSampleSize = heightRatio &lt; widthRatio ? heightRatio : widthRatio;  
    }  
    return inSampleSize;  
}  
</code></pre>

<p>使用这个方法，首先你要将BitmapFactory.Options的inJustDecodeBounds属性设置为true，解析一次图片。然后将BitmapFactory.Options连同期望的宽度和高度一起传递到到calculateInSampleSize方法中，就可以得到合适的inSampleSize值了。之后再解析一次图片，使用新获取到的inSampleSize值，并把inJustDecodeBounds设置为false，就可以得到压缩后的图片了。</p>

<pre><code>public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId,  
        int reqWidth, int reqHeight) {  
    // 第一次解析将inJustDecodeBounds设置为true，来获取图片大小  
    final BitmapFactory.Options options = new BitmapFactory.Options();  
    options.inJustDecodeBounds = true;  
    BitmapFactory.decodeResource(res, resId, options);  
    // 调用上面定义的方法计算inSampleSize值  
    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);  
    // 使用获取到的inSampleSize值再次解析图片  
    options.inJustDecodeBounds = false;  
    return BitmapFactory.decodeResource(res, resId, options);  
}  
</code></pre>

<p>下面的代码非常简单地将任意一张图片压缩成100*100的缩略图，并在ImageView上展示。</p>

<pre><code>mImageView.setImageBitmap(  
    decodeSampledBitmapFromResource(getResources(), R.id.myimage, 100, 100));  
</code></pre>

<h4>使用图片缓存技术</h4>

<p>在你应用程序的UI界面加载一张图片是一件很简单的事情，但是当你需要在界面上加载一大堆图片的时候，情况就变得复杂起来。在很多情况下，（比如使用ListView, GridView 或者 ViewPager 这样的组件），屏幕上显示的图片可以通过滑动屏幕等事件不断地增加，最终导致OOM。</p>

<p>为了保证内存的使用始终维持在一个合理的范围，通常会把被移除屏幕的图片进行回收处理。此时垃圾回收器也会认为你不再持有这些图片的引用，从而对这些图片进行GC操作。用这种思路来解决问题是非常好的，可是为了能让程序快速运行，在界面上迅速地加载图片，你又必须要考虑到某些图片被回收之后，用户又将它重新滑入屏幕这种情况。这时重新去加载一遍刚刚加载过的图片无疑是性能的瓶颈，你需要想办法去避免这个情况的发生。</p>

<p>这个时候，使用内存缓存技术可以很好的解决这个问题，它可以让组件快速地重新加载和处理图片。下面我们就来看一看如何使用内存缓存技术来对图片进行缓存，从而让你的应用程序在加载很多图片的时候可以提高响应速度和流畅性。</p>

<p>内存缓存技术对那些大量占用应用程序宝贵内存的图片提供了快速访问的方法。其中最核心的类是LruCache (此类在android-support-v4的包中提供) 。这个类非常适合用来缓存图片，它的主要算法原理是把最近使用的对象用强引用存储在 LinkedHashMap 中，并且把最近最少使用的对象在缓存值达到预设定值之前从内存中移除。</p>

<p>在过去，我们经常会使用一种非常流行的内存缓存技术的实现，即软引用或弱引用 (SoftReference or WeakReference)。但是现在已经不再推荐使用这种方式了，因为从 Android 2.3 (API Level 9)开始，垃圾回收器会更倾向于回收持有软引用或弱引用的对象，这让软引用和弱引用变得不再可靠。另外，Android 3.0 (API Level 11)中，图片的数据会存储在本地的内存当中，因而无法用一种可预见的方式将其释放，这就有潜在的风险造成应用程序的内存溢出并崩溃。</p>

<p>为了能够选择一个合适的缓存大小给LruCache, 有以下多个因素应该放入考虑范围内，例如：</p>

<h5>• 你的设备可以为每个应用程序分配多大的内存？</h5>

<h5>• 设备屏幕上一次最多能显示多少张图片？有多少图片需要进行预加载，因为有可能很快也会显示在屏幕上？</h5>

<h5>• 你的设备的屏幕大小和分辨率分别是多少？一个超高分辨率的设备（例如 Galaxy Nexus) 比起一个较低分辨率的设备（例如 Nexus S），在持有相同数量图片的时候，需要更大的缓存空间。</h5>

<h5>• 图片的尺寸和大小，还有每张图片会占据多少内存空间。</h5>

<h5>• 图片被访问的频率有多高？会不会有一些图片的访问频率比其它图片要高？如果有的话，你也许应该让一些图片常驻在内存当中，或者使用多个LruCache 对象来区分不同组的图片。</h5>

<h5>• 你能维持好数量和质量之间的平衡吗？有些时候，存储多个低像素的图片，而在后台去开线程加载高像素的图片会更加的有效。</h5>

<p>并没有一个指定的缓存大小可以满足所有的应用程序，这是由你决定的。你应该去分析程序内存的使用情况，然后制定出一个合适的解决方案。一个太小的缓存空间，有可能造成图片频繁地被释放和重新加载，这并没有好处。而一个太大的缓存空间，则有可能还是会引起 Java.lang.OutOfMemory 的异常。</p>

<p>下面是一个使用 LruCache 来缓存图片的例子：</p>

<pre><code>private LruCache&lt;String, Bitmap&gt; mMemoryCache;  

@Override  
protected void onCreate(Bundle savedInstanceState) {  
    // 获取到可用内存的最大值，使用内存超出这个值会引起OutOfMemory异常。  
    // LruCache通过构造函数传入缓存值，以KB为单位。  
    int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);  
    // 使用最大可用内存值的1/8作为缓存的大小。  
    int cacheSize = maxMemory / 8;  
    mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) {  
        @Override  
        protected int sizeOf(String key, Bitmap bitmap) {  
            // 重写此方法来衡量每张图片的大小，默认返回图片数量。  
            return bitmap.getByteCount() / 1024;  
        }  
    };  
}  

public void addBitmapToMemoryCache(String key, Bitmap bitmap) {  
    if (getBitmapFromMemCache(key) == null) {  
        mMemoryCache.put(key, bitmap);  
    }  
}  

public Bitmap getBitmapFromMemCache(String key) {  
    return mMemoryCache.get(key);  
}  
</code></pre>

<p>在这个例子当中，使用了系统分配给应用程序的八分之一内存来作为缓存大小。在中高配置的手机当中，这大概会有4兆(32/8)的缓存空间。一个全屏幕的 GridView 使用4张 800x480分辨率的图片来填充，则大概会占用1.5兆的空间(800<em>480</em>4)。因此，这个缓存大小可以存储2.5页的图片。</p>

<p>当向 ImageView 中加载一张图片时,首先会在 LruCache 的缓存中进行检查。如果找到了相应的键值，则会立刻更新ImageView ，否则开启一个后台线程来加载这张图片。</p>

<pre><code>public void loadBitmap(int resId, ImageView imageView) {  
    final String imageKey = String.valueOf(resId);  
    final Bitmap bitmap = getBitmapFromMemCache(imageKey);  
    if (bitmap != null) {  
        imageView.setImageBitmap(bitmap);  
    } else {  
        imageView.setImageResource(R.drawable.image_placeholder);  
        BitmapWorkerTask task = new BitmapWorkerTask(imageView);  
        task.execute(resId);  
    }  
}  
</code></pre>

<p>BitmapWorkerTask 还要把新加载的图片的键值对放到缓存中。</p>

<pre><code>class BitmapWorkerTask extends AsyncTask&lt;Integer, Void, Bitmap&gt; {  
    // 在后台加载图片。  
    @Override  
    protected Bitmap doInBackground(Integer... params) {  
        final Bitmap bitmap = decodeSampledBitmapFromResource(  
                getResources(), params[0], 100, 100);  
        addBitmapToMemoryCache(String.valueOf(params[0]), bitmap);  
        return bitmap;  
    }  
}  
</code></pre>

<p>掌握了以上两种方法，不管是要在程序中加载超大图片，还是要加载大量图片，都不用担心OOM的问题了!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[打造可以共用的Adapter]]></title>
    <link href="http://wentao1990.github.io/blog/2015/08/12/android-commonAdapter/"/>
    <updated>2015-08-12T19:14:31+08:00</updated>
    <id>http://wentao1990.github.io/blog/2015/08/12/android-commonAdapter</id>
    <content type="html"><![CDATA[<h3>前言：</h3>

<p>在我们开发android项目中，会在多个地方使用ListView展示内容，然后每个ListView都要对应一个Adapter来装载数据。这样的话代码就会有许多的冗余，就算写个BaseAdapter抽取部分代码，也有很多的冗余代码避免不了，至少那十几个类文件是确确实实存在那的（取决于项目需求）。下面我们来一起打造一个共用的Adapter,一个搞定所有ListView的数据装载。</p>

<h5>传统的写法我就不贴出来了，自己回想一下大概就很清楚了。</h5>

<h3>第一步：打造共用的ViewHolder</h3>

<p>一个有经验的开发者在写Adapterd的时候是不会忘记写ViewHolder的，而ViewHolder无非就是item的复用，解决效率和负载问题。所以，若要打造一个共用的Adapter，那么一个共用的ViewHolder是必不可少的。</p>

<p>ViewHolder的原理是通过convertView.setTag(this)与convertView进行绑定,然后当convertView被复用时，直接通过getTag方法拿到ViewHolder对象，直接操作里面封装的convertView中的控件，从而省去了findViewById的时间。也就说，每个convertView都会绑定一个ViewHolder对象来存储布局中的控件。那么我们只要写出一个通用的ViewHolder，然后对于任意的convertView，提供一个对象让其setTag即可；</p>

<p> <!--more--></p>

<p>既然是通用，那么我们这个ViewHolder就不可能含有各种控件的成员变量了，因为每个Item的布局是不同的，最好的方式是什么呢？
提供一个容器，专门存每个Item布局中的所有控件，而且还要能够查找出来；既然需要查找，那么ListView肯定是不行了，需要一个键值对进行保存，键为控件的Id，值为控件的引用，相信大家立刻就能想到Map；但是我们不用Map，因为有更好的替代类，就是我们android提供的SparseArray这个类，和Map类似，但是比Map效率，不过键只能为Integer.</p>

<p>下面直接贴出代码：</p>

<pre><code>/**
 * ClassName: ViewHolder
 * Fuction: 通用ViewHolder
 * Author：Knight
 * Created  2015/8/10 0010.
 */
public class ViewHolder {
private final SparseArray&lt;View&gt; mViews;//存储控件集合
private View mConvertView;

private ViewHolder(Context context, ViewGroup parent, int layoutId, int position) {
    this.mViews = new SparseArray&lt;View&gt;();
    mConvertView = LayoutInflater.from(context).inflate(layoutId, parent, false);
    //setTag
    mConvertView.setTag(this);
}

/**
 * 获取ViewHolder对象
 *
 * @param context
 * @param convertView Item
 * @param parent      Item载体
 * @param layoutId    Item布局资源id
 * @param position    Item游标
 * @return
 */
public static ViewHolder get(Context context, View convertView
        , ViewGroup parent, int layoutId, int position) {
    if (convertView == null) {
        return new ViewHolder(context, parent, layoutId, position);
    }

    return (ViewHolder) convertView.getTag();
}

/**
 * 根据id获取控件
 *
 * @param viewId
 * @param &lt;T&gt;
 * @return
 */
public &lt;T extends View&gt; T getByIdView(int viewId) {
    View view = mViews.get(viewId);
    if (view == null) {
        view = mConvertView.findViewById(viewId);
        mViews.put(viewId, view);
    }
    return (T) view;
}

/**
 * 返回item
 *
 * @return
 */
public View getConvertView() {return mConvertView;}
</code></pre>

<p>与传统的ViewHolder不同，我们使用了一个SparseArray<View>用于存储与之对于的convertView的所有的控件，当需要拿这些控件时，通过getView(id)进行获取；</p>

<h3>第二步：打造共用的Adapter</h3>

<p>Adapter一般需要保持一个List对象，存储一个Bean的集合，不同的ListView，Bean肯定是不同的，这个CommonAdapter肯定需要支持泛型，内部维持一个List<T>，就解决我们的问题了；</p>

<p>下面贴出代码：</p>

<pre><code>/**
 * ClassName: CommonAdapter
 * Fuction: 通用适配器
 * Author：Knight
 * Created  2015/8/10 0010.
 */
public abstract class CommonAdapter&lt;T&gt; extends BaseAdapter {
    private Context mContext;
    private List&lt;T&gt; mDatas;
    private int mLayoutId;
    private Object object;

    public CommonAdapter(Context context, List&lt;T&gt; datas, int layoutId) {
        this.mContext = context;
        this.mDatas=datas;
        this.mLayoutId = layoutId;
        this.object=new Object();
    }

    @Override
    public View getView(int i, View view, ViewGroup viewGroup) {
        //创建一个ViewHolder对象
        final ViewHolder holder = ViewHolder.get(mContext, view, viewGroup, mLayoutId, i);
        //子类的处理逻辑
        convert(holder,mDatas.get(i));
        //return view
        return holder.getConvertView();
    }

     /**
     * 需要子类实现的逻辑
     *
     * @param holder
     * @param item
     */
    protected abstract void convert(ViewHolder holder, T item);

    @Override
    public int getCount() {
        return mDatas == null ? 0 : mDatas.size();
    }

    @Override
    public T getItem(int i) {
        return mDatas.get(i);
    }

    @Override
    public long getItemId(int i) {
        return i;
    }

}
</code></pre>

<p>可以看出来我们的CommonAdapter是一个抽象类，使用者需要实现convert方法，从代码的逻辑来看，调用者（一般都是Activity)只需要实现convert方法来填写自身的处理逻辑即可，如settext、单击、长按。这是不是OO设计原则？</p>

<p>下面贴出调用的Activity代码：</p>

<pre><code>mListView= (ListView) findViewById(R.id.lv_brant);
......

mListView.setAdapter(new CommonAdapter&lt;UserConfInfo.TBrandOptionEntity.DataEntity&gt;(this
        ,ConfUtils.getBrandList(typeId),R.layout.brand_list_item) {
            @Override
            protected void convert(ViewHolder holder, final UserConfInfo.TBrandOptionEntity.DataEntity item) {
                TextView textView=holder.getByIdView(R.id.textview);
                textView.setText("支付宝");
            }
        });
</code></pre>

<h3>第三步：封装需要使用的功能到ViewHolder</h3>

<p>其实可以看出，完成上面两步之后，一个共用的Adapter就已经打造完成了。不过ViewHolder还可以做很多事情，由上可以看出，ViewHolder里维护了布局中的控件，我们最终还是去操作处理这些控件，如：赋值、跳转、数据交互等。那么为了更好的减少代码量（本人有点代码洁癖），我们可以把用到的功能都封装进ViewHoldr,看完下面的代码就会明白了。</p>

<p>下面贴出封装功能后的ViewHolder:</p>

<pre><code> /**
 * 设置view内容
 *
 * @param viewId
 * @param conent
 * @return
 */
public ViewHolder setText(int viewId, String conent) {
    TextView textView = getByIdView(viewId);
    textView.setText(conent);
    return this;
}

/**
 * 设置控件背景
 *
 * @param viewId
 * @param resourceId
 * @return
 */
public ViewHolder setBackgroundResource(int viewId, int resourceId) {
    getByIdView(viewId).setBackgroundResource(resourceId);

    return this;
}

/**
 * 设置view显示状态
 *
 * @param viewId
 * @param visibility
 * @return
 */
public ViewHolder setVisibility(int viewId, int visibility) {
    getByIdView(viewId).setVisibility(visibility);
    return this;
}

/**
 * 设置图片
 *
 * @param viewId
 * @param resId
 * @return
 */
public ViewHolder setImageResource(int viewId, int resId) {
    ImageView view = getByIdView(viewId);
    view.setImageResource(resId);
    return this;
}

/**
 * 设置图片
 *
 * @param viewId
 * @param bitmap
 * @return
 */
public ViewHolder setImageBitmap(int viewId, Bitmap bitmap) {
    ImageView view = getByIdView(viewId);
    view.setImageBitmap(bitmap);
    return this;
}

/**
 * 设置textview字体颜色
 *
 * @param viewId
 * @param resId
 * @return
 */
public ViewHolder setTextColorResource(int viewId, int resId) {
    TextView textView = getByIdView(viewId);
    textView.setTextColor(resId);

    return this;
}

/**
 * 设置控件选中状态
 *
 * @param viewId
 * @param b
 * @return
 */
public ViewHolder setChecked(int viewId, boolean b) {
    CheckBox checkBox = getByIdView(viewId);
    checkBox.setChecked(b);

    return this;
}

/**
 * 绑定控件的多选事件
 *
 * @param viewId
 * @param listener
 * @return
 */
public ViewHolder setOnCheckedChangeListener(int viewId, CompoundButton.OnCheckedChangeListener listener) {
    CheckBox checkBox = getByIdView(viewId);
    checkBox.setOnCheckedChangeListener(listener);

    return this;
}

/**
 * 绑定view单击事件
 *
 * @param viewId
 * @param listener
 * @return
 */
public ViewHolder setOnClickListener(int viewId, View.OnClickListener listener) {
    View view = getByIdView(viewId);
    view.setOnClickListener(listener);

    return this;
}
</code></pre>

<p>完成以上三步后，一个不算完美但还能凑合用的共用Adapter就打造好了，整个项目的代码量应该会减少百分之一，多少还会有些神清气爽的感觉。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈App安全]]></title>
    <link href="http://wentao1990.github.io/blog/2015/07/09/android-safety/"/>
    <updated>2015-07-09T20:52:25+08:00</updated>
    <id>http://wentao1990.github.io/blog/2015/07/09/android-safety</id>
    <content type="html"><![CDATA[<h5>前言：大多数开发者认为，iOS系统的封闭性使APP也更加安全，事实上，根据国外某安全服务商的最新调查显示：iOS前100名付费应用中87%均遭黑客破解。内购破解、源代码破解、本地数据窃取、本地数据窃取等手段时刻都在威胁着移动APP的安全。由于现在智能手机的普及度越来越高，APP的安全问题也越来越多的曝光在群众视野之内，仔细查阅下资料，真是与PC端程序有过之而无不及。本文楼主就以Android应用APP为例，介绍下破解和防破解的一些常用手段。</h5>

<p>（早在大学期间，我就和室友一起编写过一些游戏脚本兜售给玩家，以此赚取一些生活费用。那时我们用VB语言编写一些简单的游戏挂机辅助软件，就是模拟按键操作，由于当时对行业认知有限，我们编写的软件只是简单的加了个Protect外壳就投入到市场上，后来发现淘宝上有三五家商家在兜售我们的破解软件。）</p>

<!--more-->


<h4>常用的防破解方式：</h4>

<p><strong>• 1： 代码混淆</strong></p>

<p>最早的应用保护当属代码混淆，谷歌官方发布的sdk中就包含ProGuard这种混淆工具。混淆工具会把你用java语言编写的代码的类名、变量名混淆为自己定义的格式，这样可以增加破解者在破解时阅读难度。如下图：</p>

<p><strong>不足：</strong></p>

<p>这种方法其实算不上防破解，只不过是增加破解者的时间成本而已，好比多穿几件衣服。。。你们懂的。</p>

<p><strong>• 2： 自我校验</strong></p>

<p>通俗的讲，自我校验就是在程序中加一些对自己应用的完整性校验。我们可以借助软件的签名、计算软件的dex的md5值、利用HTTP协议从服务器上获取一段数据来完成。这种保护可以使软件在二次打包的时候不能运行，算是真正意义上的一种防破解手段，目前市面上多数软件都是采用这种方式，可以阻挡一些菜鸟级的破解者了。</p>

<p><strong>不足：</strong></p>

<p>计算机在执行指令的时候是按照预先定义好的逻辑（开发者写的）去执行，然而如果破解者对开发者校验的地方近进行了修改，那么计算机也会按照新的逻辑执行。也就是说，破解者如果修改你校验数据的逻辑后，就呵呵了。。。</p>

<p><strong>• 3： Dex文件保护</strong></p>

<p>a.隐藏dex文件</p>

<p>既然dex文件中包含了核心逻辑，那么把dex隐藏，再通过另外的方式加载起来，是不是就能达到保护dex的目的了呢？于是这成为些第三方加固产品保护应用的方式。他们通过加密甚至压缩（早期是不存在压缩的，只是单纯的加密）方式把dex转换为另外一个文件。而被加固后的apk里面的dex则是那些第三方加固产品用来启动和加载隐藏dex的入口，也就是壳。</p>

<p>b.对dex文件进行变形</p>

<p>这里所说的变形，不同于封建社会时期提到的变形。这种办法不隐藏dex，而是让dex保留在外面，但是当破解者去分析这个dex的时候，会发现dex里面的内容是不完整的。</p>

<p>c.对dex结构进行变形</p>

<p>此类方法是比较复杂的，了解dex结构的人应该很清楚，dex结构中包含DexClassDef、ClassDataItem、DexCode，这些是dalvik虚拟机运行一个dex必不可少的部分，特别是DexCode，DexCode包含了虚拟机运行的字节码指令。</p>

<p>部分第三方加固产品开始尝试这种方式，他们的保护方案中可能抽取了DexCode中的部分，然后对字节码指令添加nop，或者连ClassDataItem和DexCode一同抽取，或者对上面提到的三个部分都做处理。抽取完之后，还要做修正、修复等工作，总之很烦锁。因为dex运行时有很多关于dex的校验，即使校验通过还有一些偏移问题。</p>

<p><strong>不足：</strong></p>

<p>基本世面上的dex变形都可以通过baksmali来得到smali，这样破解者就可继续分析。而manifset文件格式官方有明确的规范，破解者按照规范去解析，遇到不正确字节可以推敲，最终还是可以将其还原。</p>

<p><strong>• 4： So保护</strong></p>

<p>a.修改Elf头、节表</p>

<p>我们知道so其实是一个ELF文件，ELF文件有着自己的格式。有些第三方加固保护是对so文件进行保护，他们的做法是稍微修改一下ELF头或者节表信息，因为这并不会影响程序的正常运行。</p>

<p>b.选择开源加壳工具</p>

<p>　　
最常用的当属UPX壳，因为它支持arm架构的ELF加固。在加壳之后再对原文件做一些处理，这样对破解者的分析工作又增加了一些难度。
　　</p>

<p>c.进程防调试、或增加调试难度</p>

<p>有时候静态分析是非常局限的，这个时候动态分析的好处就体现出来了，然而动态分析的核心就是调试，而调试一个进程首先要ptrace这个进程，如果能有效的防止进程被ptrace，就能有效的防止动态调试。当然还有其他反调试技术，或者增加调试难度等等。</p>

<h4>总结：</h4>

<p>理论上，没有任何一款软件可以做到100%的防破解，但是我们可以增加破解者对自己软件的破解难度。如果觉得没有必要或者没有精力去做这些，可以使用一些第三方的加固工具来为自己的软件增加一道保护壳。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[熟悉网络端口]]></title>
    <link href="http://wentao1990.github.io/blog/2015/07/05/network-port/"/>
    <updated>2015-07-05T22:55:10+08:00</updated>
    <id>http://wentao1990.github.io/blog/2015/07/05/network-port</id>
    <content type="html"><![CDATA[<p>计算机中的“端口”是英文port意译，可以认为计算机与外界通信交流的出口。其硬件领域的端口又称接口，如USB端口、串口端口，软件领域的端口一般指网络中面向连接服务和无连接服务的通信协议端口是—种抽象的软件结构，包括一些数据结构和I/O基本输入输出缓冲区，这类端口也是黑客们入侵计算机的途径之一。 在一台计算机中最多有65536个端口，我们可以按照端口号将他们划分为以下三类。</p>

<h3>1、公认端口</h3>

<p>从O到1023，它们紧密绑定(binding)于一服务．通常这些端口的通信明确表明了某种服务的协议，例如．80端口实际上总是月于HTTPP通信。</p>

<h3>2、注册端口</h3>

<p>从1024到49151，他们松散的绑定于一服务。也就是说有许多服务绑定于这些端口，这些端口同样用于许多其他目的，例如：许多系统处理动态端口从1024左右开始．</p>

<h3>3、动态和/或私有端口 <!--more--></h3>

<p>从49152到65535理论上，不应为服务分配这些端口，实际上，机器通常从1024起分配动态端口。但也
有例外．SUN的RPC端口从32768开始．</p>

<h3>如何关闭端口？</h3>

<p>比如在Windows 2000/XP中关闭SMTP服务的25端口，可以这样做：首先打开“控制面板”，双击“管理工具”，再双击“服务”。接着在打开的服务窗口中找到并双击“Simple Mail Transfer Protocol
（SMTP）”服务，单击“停止”按钮来停止该服务，然后在“启动类型”中选择“已禁用”，最后单击
“确定”按钮即可。这样，关闭了SMTP服务就相当于关闭了对应的端口。</p>

<h3>如何开启端口？</h3>

<p>如果要开启该端口只要先在“启动类型”选择“自动”，单击“确定”按钮，再打开该服务，在“服务
状态”中单击“启动”按钮即可启用该端口，最后，单击“确定”按钮即可。
另外在网络连接属性中，选择“TCP/IP协议”属性，打开高级TCP/IP设置，在选项的那个页面打开
TCP/IP筛选，在出现的设置窗口中也可以根据实现情况设置端口的打开和关闭，默认是未启用TCP/IP筛选。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unity3D项目融合到Android项目中]]></title>
    <link href="http://wentao1990.github.io/blog/2015/07/03/android-unity3D/"/>
    <updated>2015-07-03T19:44:10+08:00</updated>
    <id>http://wentao1990.github.io/blog/2015/07/03/android-unity3D</id>
    <content type="html"><![CDATA[<h2>需求：</h2>

<h3>有一个Android项目，里面要添加一个unity3D做的模块，然后把它们融合到一个项目中，这是两个独立的项目，需要把unity3D融合到Android项目中，如果是在项目设计架构之前选择一个为基点做二次开发，那就没有这么奇葩的需求了，然并卵！<!--more--></h3>

<h3>注：</h3>

<p>Unity3D是一款国外的3D游戏引擎，最近几年在国内火了起来，算是在游戏引擎里面比较新颖的技术吧，写好的项目可以直接导出Android和Ios版本，相当给力，可以直接在手机上跑了。说到这里，已经有一个Android项目出来了，且放在这，下面贴上Unity3D导出的Android版本的结构目录。
<img src="http://i.imgur.com/SkSGFW0.png" alt="" /></p>

<p>可以看的出它就是一个完整的Android项目，这样的话我们就能有至少两种思路来解决这个奇葩的需求。</p>

<h3>一.捆绑安装</h3>

<p>把unity3D虽然主程序静默安装到用户手机里面，然后在app内部开启unity3D程序并通信。很显然这样做的缺点太明显，技术层次也太LOW，作为一个高逼格的程序员显然是不屑于此的。由于此思路不适合在老板面前装逼，故不在此讨论。</p>

<h3>二.代码合并</h3>

<p>把unity3D导出的android项目代码合并到主项目里即可，也很简单，跟着下面步骤走完即可。</p>

<p>1.在unity3D编辑器的安装目录中找到unity-classes.jar包引入到主程序libs中。这个unity for android的支持包。</p>

<p>2.整合两个AndroidManifest.xml文件找到unity3DAndroidManifest.xml文件中的activity节点复制到主项目的AndroidManifest.xml文件中，记着把过滤器注释掉，也就是 <intent-filter>里面的内容。</p>

<p>3.把unity3D Android项目中的assets目录下的bin文件复制到主项目assets目录下</p>

<p><img src="http://i.imgur.com/3NbzTJH.png" alt="" /></p>

<p>4.最后把unity项目中的activity复制到主项目中</p>

<h5>UnityPlayerProxyActivity这个类主要就是在程序运行时获取设备系统的版本，然后根据系统版本自行判断启动UnityPlayerActivity还是UnityPlayerNativeActivity。UnityPlayerActivity是UnityPlayerNativeActivity的子类根据unity官方说明UnityPlayerNativeActivity加载的比较快，但是需要android2.3系统版本以上支持，因为引用了UnityPlayerNativeActivity继承了NativeActivity类，而这个类是从android系统中引入的，在2.3版本之前没有此类。那么现在就知道了，UnityPlayerNativeActivity类其实就unity3D加载的入口，一切模型动画渲染都是从这里开始加载的，那么也就可以把UnityPlayerNativeActivity当作一个普通的android中的activity使用，调用、复用、销毁，它也具备activity的生命周期，因为往深去看，其实就是一个activity。完成以上步骤，就完成了所有的整合，以后若unity3D模块更新迭代后，直接把assets下的bin复制替换掉主项目中的即可。</h5>

<p>有时间后面再分享些整合后在模型（UnityPlayerNativeActivity类）中修改界面和一些交互注意事项方面的东西与大家探讨一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Studio 之 Gradle 基础]]></title>
    <link href="http://wentao1990.github.io/blog/2015/06/19/android-gradle/"/>
    <updated>2015-06-19T19:32:55+08:00</updated>
    <id>http://wentao1990.github.io/blog/2015/06/19/android-gradle</id>
    <content type="html"><![CDATA[<h3>● Gradle 介绍</h3>

<p>Gradle是一种依赖管理工具，基于Groovy语言。主要是面向Java应用程序为主，它抛弃了基于XML的各种繁琐配置，取而代之的是一种基于Groovy的内部领域特定（DSL）语言。</p>

<h3>● Gradle 基本概念</h3>

<p>下面根据Android Studio 文件目录逐一说明。</p>

<p><img src="http://i.imgur.com/BTNr0t8.png" alt="" /></p>

<h4>▶ 1 project # build.gradle 文件</h4>

<p>这个文件第一行有句注释： <!--more--></p>

<pre><code>//Top-level build file where you can add configuration options common to all sub-projects/modules.
</code></pre>

<p>意思大概就是：此文件是顶级构建文件，你可以在这里配置所有需要的子模块。（是基于整个 project 的配置）</p>

<pre><code>// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
//构建过程依赖的仓库
repositories {
jcenter()
}
//构建过程需要依赖的库
dependencies {
 //下面声明的是gradle插件的版本
 classpath 'com.android.tools.build:gradle:1.1.0'
 // NOTE: Do not place your application dependencies here; they belong
 // in the individual module build.gradle files
}
}
//这里面配置整个项目依赖的仓库,这样每个module就不用配置仓库了
allprojects {
     repositories {
          jcenter()
     }
}
</code></pre>

<p>注：大家可能很奇怪，为什么仓库repositories需要声明两次，这其实是由于它们作用不同，buildscript中的仓库是gradle脚本自身需要的资源，而allprojects下的仓库是项目所有模块需要的资源。所以大家千万不要配错了。</p>

<h4>▶ 2 module#build.gradle 文件</h4>

<p>这个文件和上面的区别在于，此文件是配置使用的单个模块。（类似全局变量和局部变量的区别）
    //声明插件 这是一个android程序；如果是一个android依赖库，就要换成com.android.library
    apply plugin: &lsquo;com.android.application&rsquo;</p>

<pre><code>android {
    //安卓构建过程需要配置的参数
    compileSdkVersion 21 //编译SDK的版本
    buildToolsVersion "21.1.1"//build tools的版本（本地需要要有此版本的SDK）
    //默认配置，会同时应用到debug和release版本上
    defaultConfig {
        applicationId "com.wuwentao.start"// 应用的包名
        minSdkVersion 14 //支持最低的版本
        targetSdkVersion 23 //目标版本
        versionCode 1 //版本号
        versionName "1.0" //版本名
    }
    buildTypes {
         //这里面可以配置debug和release版本的一些参数，比如混淆、签名配置等
        release {
            minifyEnabled false //是否混淆
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' //混淆文件位置
        }
    }
}

dependencies {
    //项目使用到的依赖库和jar包
    compile fileTree(dir: 'libs', include: ['*.jar'])
    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
        exclude group: 'com.android.support', module: 'support-annotations'
    })
    compile 'com.android.support:appcompat-v7:23.4.0'
    testCompile 'junit:junit:4.12'
}
</code></pre>

<h4>▶ 3 gradle-wrapper.properties 文件</h4>

<p>gradle wrapper task利用gradle-wrapper.properties来下载指定的gradle</p>

<h4>▶ 4 proguard-rules.pro 文件</h4>

<p>Android Studio 默认自带的混淆文件，可以在这里配置一些混淆参数。当然也可以自定义一个混淆文件，需要在 module#build.gradle 指明其路径。下面贴出一些混淆的参数配置：</p>

<pre><code>-optimizationpasses 5          # 指定代码的压缩级别
-dontusemixedcaseclassnames   # 是否使用大小写混合
-dontpreverify           # 混淆时是否做预校验
-verbose                # 混淆时是否记录日志

-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*  # 混淆时所采用的算法

-keep public class * extends android.app.Activity      # 保持哪些类不被混淆
-keep public class * extends android.app.Application   # 保持哪些类不被混淆
-keep public class * extends android.app.Service       # 保持哪些类不被混淆
-keep public class * extends android.content.BroadcastReceiver  # 保持哪些类不被混淆
-keep public class * extends android.content.ContentProvider    # 保持哪些类不被混淆
-keep public class * extends android.app.backup.BackupAgentHelper # 保持哪些类不被混淆
-keep public class * extends android.preference.Preference        # 保持哪些类不被混淆
-keep public class com.android.vending.licensing.ILicensingService    # 保持哪些类不被混淆

-keepclasseswithmembernames class * {  # 保持 native 方法不被混淆
    native &lt;methods&gt;;
}
-keepclasseswithmembers class * {   # 保持自定义控件类不被混淆
    public &lt;init&gt;(android.content.Context, android.util.AttributeSet);
}
-keepclasseswithmembers class * {# 保持自定义控件类不被混淆
    public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);
}
-keepclassmembers class * extends android.app.Activity { # 保持自定义控件类不被混淆   
    public void *(android.view.View);
}
-keepclassmembers enum * {     # 保持枚举 enum 类不被混淆    
    public static **[] values();    
    public static ** valueOf(java.lang.String);
}
-keep class * implements android.os.Parcelable { # 保持 Parcelable 不被混淆  
    public static final android.os.Parcelable$Creator *;
}
</code></pre>

<h5>注：混淆的规则</h5>

<p>反射用到的类不混淆；  JNI方法不混淆； AndroidMainfest中的类不混淆；  四大组件和Application的子类和Framework层下所有的类默认不会进行混淆；  Parcelable的子类和Creator静态成员变量不混淆，否则会产生android.os.BadParcelableException异常；  使用GSON、fastjson等框架时，所写的JSON对象类不混淆，否则无法将JSON解析成对应的对象；  使用第三方开源库或者引用其他第三方的SDK包时，需要在混淆文件中加入对应的混淆规则；有用到WEBView的JS调用也需要保证写的接口方法不混淆；</p>

<h4>▶ 5 gradle.properties 文件</h4>

<p>是一个供 build.gradle 使用的常量配置文件，可以在这里配置签名的keystore位置，密码，keyalias等。</p>

<h4>▶ 6 settings.gradle 文件</h4>

<p>这个文件是用来配置多模块的，比如你的项目有两个模块module-a,module-b,那么你就需要在这个文件中进行配置</p>

<pre><code>include ':module-a',':module-b'
</code></pre>

<h4>▶ 7 local.properties 文件</h4>

<p>里面存放的是各插件需要的本机相关的信息, 例如Android gradle插件可能需要 SDK路径, NDK路径, 别的插件需要的可能就是其他配置信息.
还有存放敏感数据, 例如某些插件需要 用户名, 密码, api_key 等, 与隐私相关的数据.</p>

<p>例如: 在插件开发的时候, 你需要将工程打包后, publish 到远程仓库的时候, 需要 帐号, 密码, 此时, 帐号, 密码, 一般就是存放在 local.properties 里面</p>

<h5>注：local.properties 在git里面是要屏蔽掉的，local.properties 只对本地, 本机有效, 团队协作, 这个文件是不共享的.</h5>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Activity全屏模式下设置adjustResize模式失效，输入框会被软键盘挡到]]></title>
    <link href="http://wentao1990.github.io/blog/2015/06/08/adjust/"/>
    <updated>2015-06-08T23:00:52+08:00</updated>
    <id>http://wentao1990.github.io/blog/2015/06/08/adjust</id>
    <content type="html"><![CDATA[<h3>下面先介绍下adjustUnspecified、adjustResize、adjustPan三种模式的区别</h3>

<h5>1.adjustUnspecified ：</h5>

<p>Activity在没有被指定是adjustResize模式还是adjustPan模式时，系统会根据该Activity窗口是否有滚动控件，自动的挑选这两个模式的一种。如果该Activity有滚动控件，该窗口则使用adjustResize模式，重新调整大小，通过滚动可以使窗口的所有内容在一个更小的区域全部展示出来。如果该Activity没有滚动控件，则采用adjustPan模式。</p>

<h5>2.adjustResize：</h5>

<p>Activity的主窗口总是调整大小，来为屏幕上的软键盘腾出空间。  <!--more--></p>

<h5>3.adjustPan：</h5>

<p>Activity的主窗口不会调整大小来为软键盘腾出空间。然而，窗口的内容自动的移动以便当前焦点永远不会被软键盘遮盖住，这样用户总是可以看到他们将要打字的内容。这通常看来是不令人满意的，因为用户可能需要关闭软键盘，才可以点击那些被软键盘遮住的控件。   <!--more--></p>

<h4>根据以上的解释就可以很好的选择了，如果带背景图片的Activity为了防止图片变形，那么就只能选择adjustPan模式了。但是，不管选择哪种模式，在Activiy全屏下就是无效的。</h4>

<p>这个问题出现了很早，至少在2009年以前就出现了，google的Android团队一直都没有解决。<a href="http://code.google.com/p/android/issues/detail?id=5497">http://code.google.com/p/android/issues/detail?id=5497</a>   ，在Android官方问题回馈帖，这个问题的代号为“5497” ，不过这个世界永远都不缺少大神，在此推荐这其中的一个解决方法，来自：stackoverflow.com，实测有效。</p>

<p>首先：要在工程里引入AndroidBug5497Workaround类，代码如下：</p>

<pre><code>public class AndroidBug5497Workaround {
    public static void assistActivity (Activity activity) {
        new AndroidBug5497Workaround(activity);
    }

    private View mChildOfContent;
    private int usableHeightPrevious;
    private FrameLayout.LayoutParams frameLayoutParams;

    private AndroidBug5497Workaround(Activity activity) {
        FrameLayout content = (FrameLayout) activity.findViewById(android.R.id.content);
        mChildOfContent = content.getChildAt(0);
        mChildOfContent.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
            public void onGlobalLayout() {
                possiblyResizeChildOfContent();
            }
        });
        frameLayoutParams = (FrameLayout.LayoutParams) mChildOfContent.getLayoutParams();
    }

    private void possiblyResizeChildOfContent() {
        int usableHeightNow = computeUsableHeight();
        if (usableHeightNow != usableHeightPrevious) {
            int usableHeightSansKeyboard = mChildOfContent.getRootView().getHeight();
            int heightDifference = usableHeightSansKeyboard - usableHeightNow;
            if (heightDifference &gt; (usableHeightSansKeyboard/4)) {
                // keyboard probably just became visible
                frameLayoutParams.height = usableHeightSansKeyboard - heightDifference+50;
            } else {
                // keyboard probably just became hidden
                frameLayoutParams.height = usableHeightSansKeyboard;
            }
            mChildOfContent.requestLayout();
            usableHeightPrevious = usableHeightNow;
        }
    }

    private int computeUsableHeight() {
        Rect r = new Rect();
        mChildOfContent.getWindowVisibleDisplayFrame(r);
        return (r.bottom - r.top);
    }

}
</code></pre>

<p>然后：在Activity的setContentView(R.layout)后面加上AndroidBug5497Workaround.assistActivity(this)即可，如下：</p>

<pre><code>setContentView(R.layout.activity);
//一定要在setContentView后面调用
AndroidBug5497Workaround.assistActivity(this);
</code></pre>

<p>以上完美解决这个问题，感谢解决问题的大神。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android应用安全开发之防范无意识的数据泄露]]></title>
    <link href="http://wentao1990.github.io/blog/2015/05/19/androidDataLeak/"/>
    <updated>2015-05-19T22:08:15+08:00</updated>
    <id>http://wentao1990.github.io/blog/2015/05/19/androidDataLeak</id>
    <content type="html"><![CDATA[<p><strong>OWASP</strong>移动安全漏洞Top 10中第4个就是无意识的数据泄漏。当应用程序存储数据的位置本身是脆弱的时，就会造成无意识的数据泄漏。这些位置可能包括剪贴板，URL缓存，浏览器的Cookies，HTML5数据存储，分析数据等等。例如，一个用户在登录银行应用的时候已经把密码复制到了剪贴板，恶意应用程序通过访问用户剪贴板数据就可以获取密码了。</p>

<h3>0x01 避免缓存网络数据</h3>

<p>数据可以在用户无意识的情况下被各种工具捕获。开发人员经常忽视包括log/debug输出信息，Cookies，Web历史记录，Web缓存等的一些数据存储方式存在的安全隐患。例如，通常浏览器访问页面时，会在临时文件夹下保存页面的html，js，图片等等。当页面上包含敏感信息时，这些信息也会存储在临时文件中。这就造成了安全隐患。在移动设备上尽可能不要存储/缓存敏感数据。这是避免设备上缓存的数据泄漏的最好的方式。</p>

<h5>开发建议</h5>

<p>● 为了防止HTTP缓存，特别是HTTPS传输数据的缓存，开发人员应该配置Android不缓存网络数据。</p>

<p>● 为了避免为任何Web过程(如注册)缓存URL历史记录和页面数据，我们应该在Web服务器上配置HTTP缓存头。HTTP协议1.1版中，规定了缓存的使用。其中，Cache-Control: no-store这个应答头可以满足我们的需要。Cache-Control:no-store要求浏览器必须不存储响应或者引起响应的请求的任何内容。对于Web应用程序，HTML表单输入可以通过设置autocomplete=off让浏览器不缓存值。避免缓存应该在应用程序使用后通过对设备数据的取证进行验证。    <!--more--></p>

<p>● 如果你的应用程序通过WebView访问敏感数据，你可以使用 clearCache方法来删除任何存储在本地的文件。</p>

<h3>0x02 Android:避免GUI对象缓存</h3>

<p>由于多任务处理的原因，整个应用程序都可以驻留在内存中，所以Android应用程序界面也会驻留在内存中。发现或者盗取了设备的攻击者可以直接查看到仍然驻留在内存中的用户之前查看过的界面，并看到仍显示在GUI上的所以数据。银行应用程序就是一个例子，一个用户查看了交易记录，然后“退出”应用程序。攻击者通过直接启动交易视图activity可以看到以前的交易被显示出来。</p>

<h5>开发建议</h5>

<p>● 当用户注销登录的时候退出整个app。这虽然是违反android设计原则的，但是却更加安全，因为GUI界面被销毁、回收了。</p>

<p>● 在每一个activity(界面)启动的时候检测用户是否处于登录状态，如果没有则跳转到登录界面。</p>

<p>● 在用户离开(切换)应用界面或者注销登录时清除gui界面的数据</p>

<h3>0x03 限制用户名缓存</h3>

<p>如果缓存了用户名，在运行时，用户名会在任何类型的身份验证之前加载进内存，从而允许潜在的恶意进程截获用户名。</p>

<h5>开发建议</h5>

<p>很难做到既便利地为用户存储用户名，同时又能避免不安全的存储或潜在的运行时拦截造成的信息泄漏。尽管用户名不像密码那样敏感，但它属于隐私数据应该得到保护。一个安全性较高的缓存用户名的可行的方法就是存储掩蔽的用户名，而不是真实的用户名，如在身份认证的时候用hash值代替用户名。这个hash值可以包含一个唯一的设备token，这个设备token是在用户注册时获取的。使用hash和设备token的好处就是真实的用户名并没有存储在本地，也不会在加载进内存后得不到保护，将这个值复制到其它设备或者在web上使用都会因获取到的设备token值不同而不能使用。攻击者必须挖掘更多的信息(明文帐号、设备特征码、密码)才能成功的窃取用户凭证。</p>

<h3>0x04 留意键盘缓存</h3>

<p>键盘缓存是意外的数据泄漏问题之一。安卓键盘包含一个用户字典，如果一个用户在文本框输入一些文本，输入法就可能通过用户字典缓存一些由用户输入的数据，用于以后对用户的输入进行自动纠错。而此用户字典不需要什么特殊权限就在任何应用中使用。恶意软件可以通过获取键盘缓存提取这些数据。缓存的内容超出了应用程序的管理权限,所以应用程序不能从缓存中删除数据。</p>

<p>攻击示例：<a href="https://www.youtube.com/watch?v=o6SlUy5mmBQ">https://www.youtube.com/watch?v=o6SlUy5mmBQ</a></p>

<h5>开发建议</h5>

<p>● 对于任何敏感信息(不仅对密码字段)禁用自动纠错的功能。因为键盘缓存的敏感信息可能是可恢复的。</p>

<p>● 为了提高安全性，可以考虑实现自绘键盘，它可以禁用缓存，并提供其它的保护功能，如键盘监听保护。</p>

<h3>0x05 复制和粘贴</h3>

<p>无论数据源是否加密，存在于剪贴板中的敏感数据都是可以被任意修改的。如果用户复制的是明文敏感数据，那么其它应用程序通过访问剪贴板就可以获取到该明文敏感数据了。</p>

<h5>开发建议：</h5>

<p>在适当的情况下，禁用复制/粘贴处理敏感数据。消除复制选项可以减少数据暴露的风险。在安卓系统上，可以通过任何应用程序访问剪贴板，因此，如果需要共享敏感数据，建议使用content provider。</p>

<h3>0x06 敏感文件删除</h3>

<p>Android通过调用file.delete是不能安全地把文件抹去。只要文件不被覆盖就可以被进行恢复。Android Data Recovery就具备这个功能。</p>

<h6>开发建议</h6>

<p>开发者应该假定写入设备的任何数据都可以被恢复。因此，在某些情况下，加密可以提供额外的一层保护。
另外一种可能方法是删除一个文件，然后创建一个大文件覆盖所有的可用空间，迫使NAND闪存擦除所有未分配空间也是可能的。这种技术的缺点是损耗NAND闪存，导致应用和整个设备的响应速度变慢，显著增加功耗。对于大多数应用不建议使用此方法。理想的解决办法是尽可能不要在设备上存储敏感信息。</p>

<h3>0x07 屏幕截取和录制防范</h3>

<p>Android 5.0新增的屏幕录制接口，无需特殊权限，使用如下系统API即可实现屏幕录制功能：</p>

<p>发起录制请求后，系统弹出如下提示框请求用户确认：</p>

<p><img src="http://i.imgur.com/C61Xhg5.jpg" alt="" /></p>

<p>在上图中，“AZ Screen Recorder”为需要录制屏幕的软件名称，“将开始截取您的屏幕上显示的所有内容”是系统自带的提示信息，不可更改或删除。用户点击“立即开始”便开始录制屏幕，录制完成后在指定的目录生成mp4文件。
但其中存在着漏洞攻击者只需要给恶意程序构造一段特殊的，读起来很“合理的”应用程序名，就可以将该提示框变成一个UI陷阱，使其失去原有的“录屏授权”提示功能，并使恶意程序在用户不知情的情况下录制用户手机屏幕。</p>

<h5>开发建议</h5>

<p>在涉及用户隐私的Acitivity中(例如登录，支付等其他输入敏感信息的界面中)增加WindowManager.LayoutParams.FLAG_SECURE属性，该属性能防止屏幕被截图和录制。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[<译>Android-高性能编码优化]]></title>
    <link href="http://wentao1990.github.io/blog/2015/04/14/android-performs2/"/>
    <updated>2015-04-14T20:16:21+08:00</updated>
    <id>http://wentao1990.github.io/blog/2015/04/14/android-performs2</id>
    <content type="html"><![CDATA[<p>这里先事先提醒大家一句，本篇文章中讨论的编码优化技巧都是属于一些“微优化”，也就是说即使我们都按照本篇文章的技巧来优化代码，在性能方面也是看不出有什么显著的提升的。使用合适的算法与数据结构将永远是你优化程序性能的最主要手段，但本篇文章中不会讨论这一块的内容。因此，这里我们即将学习的并不是什么灵丹妙药，而是大家应该把这些技巧当作一种好的编码规范，我们在平时写代码时就可以潜移默化地使用这些编码规范，不仅能够在微观层面提升程序一定的性能，也可以让我们的代码变得更加专业，下面就让我们来一起学习一下这些技巧。</p>

<h3>避免创建不必要的对象</h3>

<p>创建对象从来都不应该是一件随意的事情，因为创建一个对象就意味着垃圾回收器需要回收一个对象，而这两步操作都是需要消耗时间的。虽说创建一个对象的代价确实非常小，并且Android 2.3版本当中又增加了并发垃圾回收器机制，这让GC操作时的停顿时间也变得难以察觉，但是这些理由都不足以让我们可以肆意地创建对象，需要创建的对象我们自然要创建，但是不必要的对象我们就应该尽量避免创建。  <!--more--></p>

<h4>下面来看一些我们可以避免创建对象的场景：</h4>

<h5>• 如果我们有一个需要拼接的字符串，那么可以优先考虑使用StringBuffer或者StringBuilder来进行拼接，而不是加号连接符，因为使用加号连接符会创建多余的对象，拼接的字符串越长，加号连接符的性能越低。</h5>

<h5>• 在没有特殊原因的情况下，尽量使用基本数据类来代替封装数据类型，int比Integer要更加高效，其它数据类型也是一样。</h5>

<h5>• 当一个方法的返回值是String的时候，通常可以去判断一下这个String的作用是什么，如果我们明确地知道调用方会将这个返回的String再进行拼接操作的话，可以考虑返回一个StringBuffer对象来代替，因为这样可以将一个对象的引用进行返回，而返回String的话就是创建了一个短生命周期的临时对象。</h5>

<h5>• 正如前面所说，基本数据类型要优于对象数据类型，类似地，基本数据类型的数组也要优于对象数据类型的数组。另外，两个平行的数组要比一个封装好的对象数组更加高效，举个例子，Foo[]和Bar[]这样的两个数组，使用起来要比Custom(Foo,Bar)[]这样的一个数组高效得多。</h5>

<p>当然上面所说的只是一些代表性的例子，我们所要遵守的一个基本原则就是尽可能地少创建临时对象，越少的对象意味着越少的GC操作，同时也就意味着越好的程序性能和用户体验。</p>

<p>静态优于抽象</p>

<p>如果你并不需要访问一个对象中的某些字段，只是想调用它的某个方法来去完成一项通用的功能，那么可以将这个方法设置成静态方法，这会让调用的速度提升15%-20%，同时也不用为了调用这个方法而去专门创建对象了，这样还满足了上面的一条原则。另外这也是一种好的编程习惯，因为我们可以放心地调用静态方法，而不用担心调用这个方法后是否会改变对象的状态（静态方法内无法访问非静态字段）。</p>

<p>对常量使用static final修饰符</p>

<p>我们先来看一下在一个类的最顶部定义如下代码：</p>

<pre><code>static int intVal = 42;  
static String strVal = "Hello, world!";  
</code></pre>

<p>编译器会为上述代码生成一个初始化方法，称为<clinit>方法，该方法会在定义类第一次被使用的时候调用。然后这个方法会将42的值赋值到intVal当中，并从字符串常量表中提取一个引用赋值到strVal上。当赋值完成后，我们就可以通过字段搜寻的方式来去访问具体的值了。</p>

<p>但是我们还可以通过final关键字来对上述代码进行优化：</p>

<pre><code>static final int intVal = 42;  
static final String strVal = "Hello, world!";  
</code></pre>

<p>经过这样修改之后，定义类就不再需要一个<clinit>方法了，因为所有的常量都会在dex文件的初始化器当中进行初始化。当我们调用intVal时可以直接指向42的值，而调用strVal时会用一种相对轻量级的字符串常量方式，而不是字段搜寻的方式。</p>

<p>另外需要大家注意的是，这种优化方式只对基本数据类型以及String类型的常量有效，对于其它数据类型的常量是无效的。不过，对于任何常量都是用static final的关键字来进行声明仍然是一种非常好的习惯。</p>

<h3>使用增强型for循环语法</h3>

<p>增强型for循环（也被称为for-each循环）可以用于去遍历实现Iterable接口的集合以及数组，这是jdk 1.5中新增的一种循环模式。当然除了这种新增的循环模式之外，我们仍然还可以使用原有的普通循环模式，只不过它们之间是有效率区别的，我们来看下面一段代码：</p>

<pre><code>static class Counter {  
    int mCount;  
}  

Counter[] mArray = ...  

public void zero() {  
    int sum = 0;  
    for (int i = 0; i &lt; mArray.length; ++i) {  
        sum += mArray[i].mCount;  
    }  
}  

public void one() {  
    int sum = 0;  
    Counter[] localArray = mArray;  
    int len = localArray.length;  
    for (int i = 0; i &lt; len; ++i) {  
        sum += localArray[i].mCount;  
    }  
}  

public void two() {  
    int sum = 0;  
    for (Counter a : mArray) {  
        sum += a.mCount;  
    }  
}  
</code></pre>

<p>可以看到，上述代码当中我们使用了三种不同的循环方式来对mArray中的所有元素进行求和。其中zero()方法是最慢的一种，因为它是把mArray.length写在循环当中的，也就是说每循环一次都需要重新计算一次mArray的长度。而one()方法则相对快得多，因为它使用了一个局部变量len来记录数组的长度，这样就省去了每次循环时字段搜寻的时间。two()方法在没有JIT（Just In Time Compiler）的设备上是运行最快的，而在有JIT的设备上运行效率和one()方法不相上下，唯一需要注意的是这种写法需要JDK 1.5之后才支持。</p>

<p>但是这里要跟大家提一个特殊情况，对于ArrayList这种集合，自己手写的循环要比增强型for循环更快，而其他的集合就没有这种情况。因此，对于我们来说，默认情况下可以都使用增强型for循环，而遍历ArrayList时就还是使用传统的循环方式吧。</p>

<h3>多使用系统封装好的API</h3>

<p>Java语言当中其实给我们提供了非常丰富的API接口，我们在编写程序时如果可以使用系统提供的API就应该尽量使用，系统提供的API完成不了我们需要的功能时才应该自己去写，因为使用系统的API在很多时候比我们自己写的代码要快得多，它们的很多功能都是通过底层的汇编模式执行的。</p>

<p>比如说String类当中提供的好多API都是拥有极高的效率的，像indexOf()方法和一些其它相关的API，虽说我们通过自己编写算法也能够完成同样的功能，但是效率方面会和这些方法差的比较远。这里举个例子，如果我们要实现一个数组拷贝的功能，使用循环的方式来对数组中的每一个元素一一进行赋值当然是可行的，但是如果我们直接使用系统中提供的System.arraycopy()方法将会让执行效率快9倍以上。</p>

<h3>避免在内部调用Getters/Setters方法</h3>

<p>我们平时写代码时都被告知，一定要使用面向对象的思维去写代码，而面向对象的三大特性我们都知道，封装、多态和继承。其中封装的基本思想就是不要把类内部的字段暴漏给外部，而是提供特定的方法来允许外部操作相应类的内部字段，从而在Java语言当中就出现了Getters/Setters这种封装技巧。</p>

<p>然而在Android上这个技巧就不再是那么的受推崇了，因为字段搜寻要比方法调用效率高得多，我们直接访问某个字段可能要比通过getters方法来去访问这个字段快3到7倍。不过我们肯定不能仅仅因为效率的原因就将封装这个技巧给抛弃了，编写代码还是要按照面向对象思维的，但是我们可以在能优化的地方进行优化，比如说避免在内部调用getters/setters方法。</p>

<p>那什么叫做在内部调用getters/setters方法呢？这里我举一个非常简单的例子：</p>

<pre><code>public class Calculate {  

    private int one = 1;  

    private int two = 2;  

    public int getOne() {  
        return one;  
    }  

    public int getTwo() {  
        return two;  
    }  

    public int getSum() {  
        return getOne() + getTwo();  
    }  
}  
</code></pre>

<p>可以看到，上面是一个Calculate类，这个类的功能非常简单，先将one和two这两个字段进行了封装，然后提供了getOne()方法获取one字段的值，提供了getTwo()方法获取two字段的值，还提供了一个getSum()方法用于获取总和的值。</p>

<p>这里我们注意到，getSum()方法当中的算法就是将one和two的值相加进行返回，但是它获取one和two的值的方式也是通过getters方法进行获取的，其实这是一种完全没有必要的方式，因为getSum()方法本身就是Calculate类内部的方法，它是可以直接访问到Calculate类中的封装字段的，因此这种写法在Android上是不推崇的，我们可以进行如下修改：</p>

<pre><code>public class Calculate {  

    private int one = 1;  

    private int two = 2;  

    ......  

    public int getSum() {  
        return one + two;  
    }  
}  
</code></pre>

<p>改成这种写法之后，我们就避免了在内部调用getters/setters方法，而对于外部而言Calculate类仍然是具有很好的封装性的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[42种常见的浏览器兼容性问题]]></title>
    <link href="http://wentao1990.github.io/blog/2015/04/13/web-browser/"/>
    <updated>2015-04-13T19:33:34+08:00</updated>
    <id>http://wentao1990.github.io/blog/2015/04/13/web-browser</id>
    <content type="html"><![CDATA[<h2>JavaScript</h2>

<h3>1.HTML对象获取问题</h3>

<p>FireFox：document.getElementById(“idName”);
ie:document.idname或者document.getElementById(“idName”).
解决办法：统一使用document.getElementById(“idName”);<!--more--></p>

<h3>2.const问题</h3>

<p>说明:Firefox下,可以使用const关键字或var关键字来定义常量;
IE下,只能使用var关键字来定义常量.
解决方法：统一使用var关键字来定义常量.</p>

<h3>3.event.x与event.y问题</h3>

<p>说明:IE下,event对象有x,y属性,但是没有pageX,pageY属性;
Firefox下,event对象有pageX,pageY属性,但是没有x,y属性.
解决方法：使用mX(mX = event.x ? event.x : event.pageX;)来代替IE下的event.x或者Firefox下的event.pageX. <!--more--></p>

<h3>4.window.location.href问题</h3>

<p>说明:IE或者Firefox2.0.x下,可以使用window.location或window.location.href;
Firefox1.5.x下,只能使用window.location.
解决方法：使用window.location来代替window.location.href.</p>

<h3>5.frame问题</h3>

<p>以下面的frame为例：
<frame id=”frameId” name="”frameName”" src="”xxx.html”" /></p>

<h4>(1)访问frame对象:</h4>

<p>IE:使用window.frameId或者window.frameName来访问这个frame对象.frameId和frameName可以同名。
Firefox:只能使用window.frameName来访问这个frame对象.
另外，在IE和Firefox中都可以使用window.document.getElementById(“frameId”)来访问这个frame对象.</p>

<h4>(2)切换frame内容:</h4>

<p>在 IE和Firefox中都可以使用window.document.getElementById(“testFrame”).src = “xxx.html”或window.frameName.location = “xxx.html”来切换frame的内容.
如果需要将frame中的参数传回父窗口(注意不是opener,而是parent frame)，可以在frame中使用parent来访问父窗口。例如：parent.document.form1.filename.value=”Aqing”;</p>

<h3>6.模态和非模态窗口问题</h3>

<p>说明:IE下,可以通过showModalDialog和showModelessDialog打开模态和非模态窗口;Firefox下则不能.
解决方法：直接使用window.open(pageURL,name,parameters)方式打开新窗口。
如果需要将子窗口中的参数传递回父窗口,可以在子窗口中使用window.opener来访问父窗口.
例如：var parWin = window.opener; parWin.document.getElementById(“Aqing”).value = “Aqing”;</p>

<h3>7.firefox与IE的父元素(parentElement)的区别</h3>

<p>IE：obj.parentElement
firefox：obj.parentNode
解决方法: 因为firefox与IE都支持DOM,因此使用obj.parentNode是不错选择.</p>

<h3>8.document.formName.item(”itemName”) 问题</h3>

<p>问题说明：IE下，可以使用document.formName.item(”itemName”) 或document.formName.elements [“elementName”];Firefox 下，只能使用document.formName.elements[“elementName”]。
解决方法：统一使用document.formName.elements[“elementName”]。</p>

<h3>9.集合类对象问题</h3>

<p>问题说明：IE下，可以使用 () 或 [] 获取集合类对象;Firefox下，只能使用 [ ]获取集合类对象。
解决方法：统一使用 [] 获取集合类对象。</p>

<h3>10.自定义属性问题</h3>

<p>问题说明：IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute() 获取自定义属性;Firefox下，只能使用getAttribute() 获取自定义属性。
解决方法：统一通过getAttribute() 获取自定义属性。
解决方法：统一使用 [] 获取集合类对象。</p>

<h3>11.input.type属性问题</h3>

<p>问题说明：IE下input.type属性为只读;但是Firefox下input.type属性为读写。
解决办法：不修改input.type属性。如果必须要修改，可以先隐藏原来的input，然后在同样的位置再插入一个新的input元素。
解决方法：统一使用 [] 获取集合类对象。</p>

<h3>12.event.srcElement问题</h3>

<p>问题说明：IE下，even对象有srcElement属性，但是没有target属性;Firefox下，even对象有target属性，但是没有srcElement属性。
解决方法：使用srcObj = event.srcElement ?event.srcElement : event.target;
如果考虑第8条问题，就改用myEvent代替event即可。
解决方法：统一使用 [] 获取集合类对象。</p>

<h3>13.body载入问题</h3>

<p>问题说明：Firefox的body对象在body标签没有被浏览器完全读入之前就存在;而IE的body对象则必须在body标签被浏览器完全读入之后才存在。
[注] 这个问题尚未实际验证，待验证后再来修改。
[注] 经验证，IE6、Opera9以及FireFox2中不存在上述问题，单纯的JS脚本可以访问在脚本之前已经载入的所有对象和元素，即使这个元素还没有载入完成。
解决方法：统一使用 [] 获取集合类对象。</p>

<h3>14.事件委托方法</h3>

<p>问题说明：IE下，使用document.body.onload = inject; 其中function inject()在这之前已被实现;在Firefox下，使用document.body.onload = inject();</p>

<h4>解决方法：统一使用document.body.onload=new Function(’inject()’); 或document.body.onload = function(){/<em> 这里是代码 </em>/}[注意] Function和function的区别。</h4>

<h3>15.Table操作问题</h3>

<p>问题说明：ie、firefox以及其它浏览器对于 table 标签的操作都各不相同，在ie中不允许对table和tr的innerHTML赋值，使用js增加一个tr时，使用appendChild方法也不管用。
解决方法：//向table追加一个空行：
var row = otable.insertRow(-1);var cell = document.createElement(“td”);cell.innerHTML = “”;cell.className = “XXXX”;row.appendChild(cell);[注] 由于俺很少使用JS直接操作表格，这个问题没有遇见过。建议使用JS框架集来操作table，如JQuery。
解决方法：统一使用 [] 获取集合类对象。</p>

<h3>16.对象宽高赋值问题</h3>

<p>问题说明：FireFox中类似obj.style.height = imgObj.height的语句无效。
Ø CSS
解决方法：统一使用 [] 获取集合类对象。</p>

<h4>1.cursor:hand VS cursor:pointer</h4>

<p>firefox不支持hand，但ie支持pointer
解决方法: 统一使用pointer
解决方法：统一使用 [] 获取集合类对象。</p>

<h4>2.innerText在IE中能正常工作，但在FireFox中却不行.</h4>

<p>需用textContent。
解决方法:
if(navigator.appName.indexOf(“Explorer”) > -1){
document.getElementById(‘element’).innerText = “my text”;
}
else{
document.getElementById(‘element’).textContent = “my text”;
}</p>

<h4>3.CSS透明</h4>

<p>IE：filter:progid:DXImageTransform.Microsoft.Alpha(style=0,opacity=60)。
FF：opacity:0.6。</p>

<h4>4.css中的width和padding</h4>

<p>在IE7和FF中width宽度不包括padding，在Ie6中包括padding.</p>

<h4>5.FF和IEBOX模型解释不一致导致相差2px</h4>

<p>box.style{width:100;border 1px;}
ie理解为box.width = 100
ff理解为box.width = 100 + 1*2 = 102 //加上边框2px
解决方法：div{margin:30px!important;margin:28px;}
注意这两个margin的顺序一定不能写反， IE不能识别!important这个属性，但别的浏览器可以识别。所以在IE下其实解释成这样：div{maring:30px;margin:28px}
重复定义的话按照最后一个来执行，所以不可以只写margin:XXpx!important;</p>

<h4>6.IE5 和IE6的BOX解释不一致</h4>

<p>IE5下div{width:300px;margin:0 10px 0 10px;}
div 的宽度会被解释为300px-10px(右填充)-10px(左填充)，最终div的宽度为280px，而在IE6和其他浏览器上宽度则是以 300px+10px(右填充)+10px(左填充)=320px来计算的。这时我们可以做如下修改 div{width:300px!important;width /**/:340px;margin:0 10px 0 10px}</p>

<h4>7.ul和ol列表缩进问题</h4>

<p>消除ul、ol等列表的缩进时，样式应写成：list-style:none;margin:0px;padding:0px;
经验证，在IE中，设置margin:0px可以去除列表的上下左右缩进、空白以及列表编号或圆点，设置padding对样式没有影响;在 Firefox 中，设置margin:0px仅仅可以去除上下的空白，设置padding:0px后仅仅可以去掉左右缩进，还必须设置list- style:none才能去除列表编号或圆点。也就是说，在IE中仅仅设置margin:0px即可达到最终效果，而在Firefox中必须同时设置margin:0px、 padding:0px以及list-style:none三项才能达到最终效果。</p>

<h4>8.元素水平居中问题</h4>

<p>FF: margin:0 auto;
IE: 父级{ text-align:center; }</p>

<h4>9.Div的垂直居中问题</h4>

<p>vertical-align:middle; 将行距增加到和整个DIV一样高：line-height:200px; 然后插入文字，就垂直居中了。缺点是要控制内容不要换行。</p>

<h4>10.margin加倍的问题</h4>

<p>设置为float的div在ie下设置的margin会加倍。这是一个ie6都存在的bug。解决方案是在这个div里面加上display:inline;
例如：
相应的css为#imfloat{
float:left;
margin:5px;/<em>IE下理解为10px</em>/
display:inline;/<em>IE下再理解为5px</em>/}
解决方法：统一使用 [] 获取集合类对象。</p>

<h4>11.IE与宽度和高度的问题</h4>

<p>IE不认得min-这个定义，但实际上它把正常的width和height当作有min的情况来使。这样问题就大了，如果只用宽度和高度，正常的浏览器里这两个值就不会变，如果只用min-width和min-height的话，IE下面根本等于没有设置宽度和高度。
比如要设置背景图片，这个宽度是比较重要的。要解决这个问题，可以这样：
#box{ width: 80px; height: 35px;}html>body #box{ width: auto; height: auto; min-width: 80px; min-height: 35px;}</p>

<h4>12.页面的最小宽度</h4>

<p>如上一个问题，IE不识别min，要实现最小宽度，可用下面的方法：
#container{ min-width: 600px; width:expression(document.body.clientWidth&lt; 600? “600px”: “auto” );}
第一个min-width是正常的;但第2行的width使用了Javascript，这只有IE才认得，这也会让你的HTML文档不太正规。它实际上通过Javascript的判断来实现最小宽度。</p>

<h4>13.DIV浮动IE文本产生3象素的bug</h4>

<p>左边对象浮动，右边采用外补丁的左边距来定位，右边对象内的文本会离左边有3px的间距.
#box{ float:left; width:800px;}
#left{ float:left; width:50%;}
#right{ width:50%;}
*html #left{ margin-right:-3px; //这句是关键}</p>

<h4>14.IE捉迷藏的问题</h4>

<p>当div应用复杂的时候每个栏中又有一些链接，DIV等这个时候容易发生捉迷藏的问题。
有些内容显示不出来，当鼠标选择这个区域是发现内容确实在页面。
解决办法：对#layout使用line-height属性或者给#layout使用固定高和宽。页面结构尽量简单。</p>

<h4>15.float的div闭合;清除浮动;自适应高度</h4>

<h5>① 例如：</h5>

<p>这里的NOTfloatC并不希望继续平移，而是希望往下排。(其中floatA、floatB的属性已经设置为float:left;)
这段代码在IE中毫无问题，问题出在FF。原因是NOTfloatC并非float标签，必须将float标签闭合。在
之间加上
这个div一定要注意位置，而且必须与两个具有float属性的div同级，之间不能存在嵌套关系，否则会产生异常。并且将clear这种样式定义为为如下即可：.clear{clear:both;}</p>

<h5>②作为外部 wrapper 的 div 不要定死高度,为了让高度能自适应，要在wrapper里面加上overflow:hidden; 当包含float的box的时候，高度自适应在IE下无效，这时候应该触发IE的layout私有属性(万恶的IE啊!)用zoom:1;可以做到，这样就达到了兼容。</h5>

<p>例如某一个wrapper如下定义：
.colwrapper{overflow:hidden; zoom:1; margin:5px auto;}</p>

<h5>③对于排版,我们用得最多的css描述可能就是float:left.有的时候我们需要在n栏的float div后面做一个统一的背景,譬如:</h5>

<p>比如我们要将page的背景设置成蓝色,以达到所有三栏的背景颜色是蓝色的目的,但是我们会发现随着left center right的向下拉长,而page居然保存高度不变,问题来了,原因在于page不是float属性,而我们的page由于要居中,不能设置成float,所以我们应该这样解决：
再嵌入一个float left而宽度是100%的DIV解决之。</p>

<h5>④万能float 闭合(非常重要!)</h5>

<p>关于 clear float 的原理可参见 [How To Clear Floats Without Structural Markup],将以下代码加入Global CSS 中,给需要闭合的div加上class=”clearfix” 即可,屡试不爽。
/<em> Clear Fix </em>/
.clearfix:after { content:”.”; display:block; height:0; clear:both; visibility:hidden; }
.clearfix { display:inline-block; }
/<em> Hide from IE Mac </em>/
.clearfix {display:block;}
/<em> End hide from IE Mac </em>/
/<em> end of clearfix </em>/
或者这样设置：.hackbox{ display:table; //将对象作为块元素级的表格显示}</p>

<h4>16.高度不适应</h4>

<p>高度不适应是当内层对象的高度发生变化时外层高度不能自动进行调节，特别是当内层对象使用margin 或padding时。
例：
#box {background-color:#eee; }
#box p {margin-top: 20px;margin-bottom: 20px; text-align:center; }
p对象中的内容
解决技巧：在P对象上下各加2个空的div对象CSS代码{height:0px;overflow:hidden;}或者为DIV加上border属性。</p>

<h4>17.IE6下图片下有空隙产生</h4>

<p>解决这个BUG的技巧有很多,可以是改变html的排版,或者设置img为display:block或者设置vertical-align属性为vertical-align:top/bottom/middle/text-bottom 都可以解决.</p>

<h4>18.对齐文本与文本输入框</h4>

<p>加上vertical-align:middle;
经验证，在IE下任一版本都不适用，而ff、opera、safari、chrome均OK!</p>

<h4>19.LI中内容超过长度后以省略号显示</h4>

<p>此技巧适用与IE、Opera、safari、chrom浏览器，FF暂不支持。</p>

<h4>20.为什么web标准中IE无法设置滚动条颜色了</h4>

<p>解决办法是将body换成html</p>

<h4>21.为什么无法定义1px左右高度的容器</h4>

<p>IE6下这个问题是因为默认的行高造成的,解决的技巧也有很多：
例如:overflow:hidden　 zoom:0.08 　 line-height:1px</p>

<h4>22.怎么样才能让层显示在FLASH之上呢</h4>

<p>解决的办法是给FLASH设置透明</p>

<h4>23.链接(a标签)的边框与背景</h4>

<p>a链接加边框和背景色，需设置 display: block, 同时设置 float: left 保证不换行。参照menubar, 给 a 和menubar设置高度是为了避免底边显示错位, 若不设 height, 可以在menubar中插入一个空格。</p>

<h4>24.超链接访问过后hover样式就不出现的问题</h4>

<p>被点击访问过的超链接样式不在具有hover和active了,很多人应该都遇到过这个问题,解决技巧是改变CSS属性的排列顺序: L-V-H-A
Code:</p>

<h4>25.FORM标签</h4>

<p>这个标签在IE中,将会自动margin一些边距,而在FF中margin则是0,因此,如果想显示一致,所以最好在css中指定margin和 padding,针对上面两个问题,我的css中一般首先都使用这样的样式ul,form{margin:0;padding:0;}。</p>

<h4>26.属性选择器(这个不能算是兼容,是隐藏css的一个bug)</h4>

<p>p[id]{}div[id]{}
这个对于IE6.0和IE6.0以下的版本都隐藏,FF和OPera作用.属性选择器和子选择器还是有区别的,子选择器的范围从形式来说缩小了,属性选择器的范围比较大,如p[id]中,所有p标签中有id的都是同样式的.</p>

<h4>27.为什么FF下文本无法撑开容器的高度</h4>

<p>标准浏览器中固定高度值的容器是不会象IE6里那样被撑开的,那我又想固定高度,又想能被撑开需要怎样设置呢?办法就是去掉height设置min-height:200px; 这里为了照顾不认识min-height的IE6 可以这样定义:
{
height:auto!important;
height:200px;
min-height:200px;
}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[仿支付宝&微信支付密码界面]]></title>
    <link href="http://wentao1990.github.io/blog/2015/03/28/customPay/"/>
    <updated>2015-03-28T22:52:26+08:00</updated>
    <id>http://wentao1990.github.io/blog/2015/03/28/customPay</id>
    <content type="html"><![CDATA[<h4>这篇文章主要介绍下支付宝和微信支付密码样式实现。如下图：</h4>

<p><img src="http://i.imgur.com/83WfVFz.png" alt="" /></p>

<p>1：绘制一个完整的界面，如下图：</p>

<p><img src="http://i.imgur.com/MqF5j8Y.png" alt="" /></p>

<p>(这个界面可以根据自己的需要自定义）  <!--more--></p>

<p>代码：</p>

<p>xml部分就不粘贴了，这里主要阐述的是逻辑代码。  <!--more--></p>

<pre><code>/**
 * 自定义支付密码显示view
 * Author：knight
 * QQ：394558536
 * Created by Administrator on 2015/3/24.
 */
public class PayPasswordView implements View.OnClickListener, View.OnLongClickListener {
    private TextView box1, box2, box3, box4, box5, box6;
    private ArrayList&lt;String&gt; mList = new ArrayList&lt;String&gt;();
    private OnPayListener listener;
    private View mView;
    private Context mContext;

    public PayPasswordView(Context mContext, OnPayListener listener) {
        getDecorView(mContext, listener);
    }

    public static PayPasswordView getInstance( Context mContext, OnPayListener listener) {
        return new PayPasswordView(mContext, listener);
    }

    public void getDecorView( Context mContext, OnPayListener listener) {
        this.listener = listener;
        this.mContext = mContext;
        mView = LayoutInflater.from(mContext).inflate(R.layout.item_paypassword, null);
        //初始化控件
        ......
    }

    /**
     *处理按键点击事件
     */
    @Override
    public void onClick(View view) {
        //这里不能使用switch()...case语句
        if (view.getId() == R.id.pay_keyboard_del) {
            parseActionType(KeyboardEnum.del);
        } else if (view.getId() == R.id.pay_keyboard_zero) {
            parseActionType(KeyboardEnum.zero);
        } else if (view.getId() == R.id.pay_keyboard_one) {
            parseActionType(KeyboardEnum.one);
        } else if (view.getId() == R.id.pay_keyboard_two) {
            parseActionType(KeyboardEnum.two);
        } else if (view.getId() == R.id.pay_keyboard_three) {
            parseActionType(KeyboardEnum.three);
        } else if (view.getId() == R.id.pay_keyboard_four) {
            parseActionType(KeyboardEnum.four);
        } else if (view.getId() == R.id.pay_keyboard_five) {
            parseActionType(KeyboardEnum.five);
        } else if (view.getId() == R.id.pay_keyboard_sex) {
            parseActionType(KeyboardEnum.sex);
        } else if (view.getId() == R.id.pay_keyboard_seven) {
            parseActionType(KeyboardEnum.seven);
        } else if (view.getId() == R.id.pay_keyboard_eight) {
            parseActionType(KeyboardEnum.eight);
        } else if (view.getId() == R.id.pay_keyboard_nine) {
            parseActionType(KeyboardEnum.nine);
        }else if(view.getId()==R.id.pay_cancel){
            parseActionType(KeyboardEnum.cancel);
        } else if(view.getId()==R.id.pay_forget_pw){
            parseActionType(KeyboardEnum.forget);
        }


    }

    /**
     *长按删除键
     * @param view
     */
    @Override
    public boolean onLongClick(View view) {
        if (view.getId() == R.id.pay_keyboard_del)
            parseActionType(KeyboardEnum.longdel);
        return false;
    }

    /**
     * 功能事件处理
     * @param type
     */

    private void parseActionType(KeyboardEnum type) {
        if (type.getType() == KeyboardEnum.ActionEnum.add) {//输入
            if (mList.size() &lt; 6) {
                mList.add(type.getValue());
                updateUi();
            }
        } else if (type.getType() == KeyboardEnum.ActionEnum.delete) {//删除
            if (mList.size() &gt; 0) {
                mList.remove(mList.get(mList.size() - 1));
                updateUi();
            }
        } else if (type.getType() == KeyboardEnum.ActionEnum.cancel) {//取消
            listener.onCancelPay();
        } else if (type.getType() == KeyboardEnum.ActionEnum.sure) {//确定（当输入6位数时触发）
            if (mList.size() &lt; 6) {
                Toast.makeText(mContext, "支付密码必须6位", Toast.LENGTH_SHORT).show();
            } else {
                String payValue = "";
                for (int i = 0; i &lt; mList.size(); i++) {
                    payValue += mList.get(i);
                }
                listener.onSurePay(payValue);
            }
        } else if (type.getType() == KeyboardEnum.ActionEnum.longClick) {//长按删除
            mList.clear();
            updateUi();
        }else if(type.getType()== KeyboardEnum.ActionEnum.forget){//忘记密码
            listener.onForgetPW();
        }

    }

   /**
    * 更新UI
    */
    private void updateUi() {
        if (mList.size() == 0) {
            box1.setText("");
            box2.setText("");
            box3.setText("");
            box4.setText("");
            box5.setText("");
            box6.setText("");
        } else if (mList.size() == 1) {
            box1.setText(mList.get(0));
            box2.setText("");
            box3.setText("");
            box4.setText("");
            box5.setText("");
            box6.setText("");
        } else if (mList.size() == 2) {
            box1.setText(mList.get(0));
            box2.setText(mList.get(1));
            box3.setText("");
            box4.setText("");
            box5.setText("");
            box6.setText("");
        } else if (mList.size() == 3) {
            box1.setText(mList.get(0));
            box2.setText(mList.get(1));
            box3.setText(mList.get(2));
            box4.setText("");
            box5.setText("");
            box6.setText("");
        } else if (mList.size() == 4) {
            box1.setText(mList.get(0));
            box2.setText(mList.get(1));
            box3.setText(mList.get(2));
            box4.setText(mList.get(3));
            box5.setText("");
            box6.setText("");
        } else if (mList.size() == 5) {
            box1.setText(mList.get(0));
            box2.setText(mList.get(1));
            box3.setText(mList.get(2));
            box4.setText(mList.get(3));
            box5.setText(mList.get(4));
            box6.setText("");
        } else if (mList.size() == 6) {
            box1.setText(mList.get(0));
            box2.setText(mList.get(1));
            box3.setText(mList.get(2));
            box4.setText(mList.get(3));
            box5.setText(mList.get(4));
            box6.setText(mList.get(5));
            //输完后自动校验密码
            parseActionType(KeyboardEnum.sure);
        }
    }

     /**
      * 事件监听接口
      */
    public interface OnPayListener {
        void onCancelPay();

        void onSurePay(String password);

        void onForgetPW();
    }

    /**
     * 获取当前View
     * @return
     */
    public View getView() {
        return mView;
    }
}
</code></pre>

<p>2：定义一个枚举类配合上面的逻辑实现</p>

<pre><code>package com.gybs.common.customview;
/**
 * 自定义支付密码类枚举
 * Author：knight
 * QQ：394558536
 * Created by Administrator on 2015/3/24.
 */
public enum KeyboardEnum {
    one(ActionEnum.add,"1"),
    two(ActionEnum.add,"2"),
    three(ActionEnum.add,"3"),
    four(ActionEnum.add,"4"),
    five(ActionEnum.add,"5"),
    sex(ActionEnum.add,"6"),
    seven(ActionEnum.add,"7"),
    eight(ActionEnum.add,"8"),
    nine(ActionEnum.add,"9"),
    zero(ActionEnum.add,"0"),
    del(ActionEnum.delete,"del"),
    longdel(ActionEnum.longClick,"longclick"),
    cancel(ActionEnum.cancel,"cancel"),
    forget(ActionEnum.forget,"forget"),
    original(ActionEnum.original,"original"),
    newPW(ActionEnum.newPW,"new"),
    sure(ActionEnum.sure,"sure");
    public enum ActionEnum{
        add,delete,longClick,cancel,sure,forget,original,newPW
    }
    private ActionEnum type;
    private String value;
    private KeyboardEnum(ActionEnum type,String value){
        this.type=type;
        this.value=value;
    }
    public ActionEnum getType() {
        return type;
    }
    public void setType(ActionEnum type) {
        this.type = type;
    }
    public String getValue() {
        return value;
    }
    public void setValue(String value) {
        this.value = value;
    }

}
</code></pre>

<p>3:定义一个dialog工具类调用上面的界面</p>

<pre><code>/**
 * 自定义支付密码dialog
 * Author：knight
 * QQ：394558536
 * Created by Administrator on 2015/3/24.
 */
public class PayPWDialog extends Dialog  {
    Activity activity;
    private View view;
    private boolean isOutSideTouch=true;

    public View getView() {
        return view;
    }
    public void setView(View view) {
        this.view = view;
    }
    public boolean isOutSideTouch() {
        return isOutSideTouch;
    }
    public void setOutSideTouch(boolean isOutSideTouch) {
        this.isOutSideTouch = isOutSideTouch;
    }
    public PayPWDialog(Context context, int theme) {
        super(context, theme);
    }
    public PayPWDialog(Context context) {
        this(context,0);
    }
    public PayPWDialog(Activity activity, View view) {
        super(activity, R.style.MyDialog);
        this.activity = activity;
        this.view=view;
    }
    public PayPWDialog(Activity activity, View view, int theme) {
        super(activity,theme);
        this.activity = activity;
        this.view=view;
    }
    public PayPWDialog(Activity activity, View view, int theme, boolean isOutSide) {
        super(activity,theme);
        this.activity = activity;
        this.view=view;
        this.isOutSideTouch=isOutSide;
    }
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(view);
        setCanceledOnTouchOutside(isOutSideTouch);

        DisplayMetrics dm = new DisplayMetrics();
        // 取得窗口属性
        activity.getWindowManager().getDefaultDisplay().getMetrics(dm);
        // 窗口的宽度
        int screenWidth = dm.widthPixels;
        int screenHeight=dm.heightPixels;
        WindowManager.LayoutParams layoutParams = this.getWindow()
                .getAttributes();
        layoutParams.width = screenWidth;
        layoutParams.height = screenHeight;
        this.getWindow().setAttributes(layoutParams);
    }

}
</code></pre>

<p>4:在需要使用的界面直接 new PayPWDialog(&hellip;)  即可</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android应用开发浅谈]]></title>
    <link href="http://wentao1990.github.io/blog/2015/03/05/android-app/"/>
    <updated>2015-03-05T19:29:47+08:00</updated>
    <id>http://wentao1990.github.io/blog/2015/03/05/android-app</id>
    <content type="html"><![CDATA[<h3>Android应用程序运行的移动设备受限于其运算能力，存储空间，及电池续航。由此，它必须是高效的。电池续航可能是一个促使你优化程序的原因，即使他看起来已经运行的足够快了。由于续航对用户的重要性，当电量耗损陡增时，意味这用户迟早会发现是由于你的程序。</h3>

<p>虽然这份文档主要包含着细微的优化，但这些绝不能成为你软件成败的关键。选择合适的算法和数据结构永远是你最先应该考虑的事情，但这超出这份文档之外。<!--more--></p>

<h4>1. 介绍</h4>

<p>写出高效的代码有两条基本的原则：
◆ 不作没有必要的工作
◆ 尽量避免内存分配。</p>

<h4>2. 明智的优化</h4>

<p>这份文档是关于Android规范的细微优化，所以先确保你已经了解哪些代码需要优化，并且知道如何去衡量你所做修改所带来的效果(好或坏)。用开投资开发的时间是有限的，所以明智的时间规划很重要。
这份文档同时确保你在算法和数据结构上作出最佳选择，同时考虑了API选择所带来的潜在影响。使用恰当的数据结构和算法比这里的任何建议都有价值，考虑API版本带来的影响会如实你选择更好的实现。
当你优化Android程序时会遇到的一个棘手问题是确保你的程序能在不同的硬件平台上运行。不同版本的虚拟机在不同处理器上的运行速度各不相同。并且不是简单的设备A比设备B快或者慢，并针对一个设备与其他设备之间做出排列。特别的，模拟器上只能评测小部分可以在设备上体现的东西。有无JIT的设备间也有着巨大差异：对于有JIT设备好的代码有时对无JIT的设备并不是最好的。如果你想知道程序在设备上的表现，就必须在上面进行测试</p>

<h4>3. 避免创建不必要的对象</h4>

<p>对象创建永远不会免费的。每个线程的分代GC给临时对象分配一个地址池能降低分配开销，但分配内存往往需要比不分配内存高的代价。
如果在用户界面周期内分配对象，会强制一个周期性的垃圾回收，给用户体验造成小小的停顿间隙。Gingerbread中介绍的并发回收也许有用，但应该避免不必要的工作。
因此，避免创建不需要的对象实例。下面是几个例子：
◆ 如果有一个返回String的方法，他的返回值通常附加在一个StringBuffer上，改变声明和实现，这样函数直接在其后面附加，而非创建一个短暂存在的临时变量。
◆ 当从输入的数据集合中读取数据时，考虑返回原始数据的子串，而非新建一个拷贝。这样你会创建一个新的对象，但是他们共享该数据的char数组。换来的是即使你仅仅使用原始输入的一部分，你也需要保证它一直存在于内存中。
一个更彻底的观点是将多维数组切割成一维数组：
◆ Int类型的数组比Integer类型的好。推而广之，两个平行的int数组要比一个(int,int)型的对象数组高效。这个定理对于任何基本数据类型的组合都通用。
◆ 如果需要实现存放元组(Foo,Bar)对象的容器，记住两个平行数组Foo[], Bar[]会优于一个(Foo,Bar)对象的数组。(例外情况是：当你设计API给其他代码调用时，最好用好的API设计来换取小的速度提升。但在自己的内部代码中，尽量尝试高效的实现。)
通常来说，尽量避免创建短时临时对象。少的对象创建意味着低频的垃圾回收。这对于用户体验产生直接的影响。</p>

<h4>4. 性能之谜</h4>

<p>前一个版本的文档给出了好多误导人的主张，这里做一些澄清：
◆ 在没有JIT的设备上，调用方法所传递的对象采用具体的类型而非接口类型会更有效(比如，传递HashMap map比传递Map map调用一个方法耗费的开销小，尽管两种情况下的map都是HashMap)。但这并不是两倍慢的情形，事实上，只相差6%，而JIT使这两种调用的效率不分伯仲。
◆ 在没有JIT的设备上，访问缓存后的字段比直接访问字段快大概20%。在有JIT的情况下，字段访问和局部访问耗费是一样的 。所以这里不值得优化，除非你觉得他会让你的代码更易读(对于final,static，及static final 变量同样适用).</p>

<h4>5. 用静态代替虚拟</h4>

<p>如果不需要访问某对象的字段，将方法设置为静态，调用会加速15%到20%。这也是一种好的做法，因为你可以通过方法声明知晓调用该方法不需要更新此对象的状态。</p>

<h4>6. 避免内部的Getters/Setters</h4>

<p>在源生语言像C++中，通常做法是用Getters(i=getCount())代替直接访问字段(i=mCount)。这是C++中一个好的习惯，因为编译器会内联这些访问，如果需要约束或者调试这些域的访问，你可以在任何时间添加代码。
在Android中，这是个不好的想法。虚方法调用代价比直接存取字段高昂的多。按照通常面向对象语言的做法在公共接口中使用Getters和Setters是有原因的，但应该在一个经常访问其字段的类中采用直接访问。
无JIT时，直接字段访问大约比调用无关紧要的getter来访问快3倍。有JIT时(直接访问字段开销和访问局部变量是一样的)，要快7倍。在Froyo版本中确实如此，但以后会在JIT中改进Getter方法的内联。</p>

<h4>7. 对常量使用Static Final修饰符</h4>

<p>考虑下面类首的声明：</p>

<pre><code>//Java代码
static int intVal = 42; static String strVal = "Hello, world!";
</code></pre>

<p>编译器生成一个类初始化方法clinit, 当类初次被使用时执行，这个方法将42存入intVal中，并得到类字符串常量strVal的引用。当这些值在后面被引用时，他们通过字段查找进行访问。
我们改进实现，采用 final关键字：</p>

<pre><code>//Java代码
static final int intVal = 42; static final String strVal = "Hello, world!";
</code></pre>

<p>类不再需要clinit方法，因为常量进入了dex文件中的静态字段初始化器中。引用intVal的代码，直接调用整形值42，而访问strVal时也会采用相对开销较小的 string constant(字符串常量)指令替代字段查找。(这种优化仅仅是针对基本数据类型和String类型常量的，而非任意的引用类型。但尽可能的将常量声明为static final类型是一种好的做法。</p>

<h4>8. 使用改进的For循环语法</h4>

<p>改进的for循环(有时被称为for-each循环)能够用于实现了iterable接口的集合类及数组中。在集合类中，迭代器促使接口访问hasNext()和next()方法，在ArrayList中，计数循环迭代要快3倍(无论有没有JIT)，但其他集合类中，改进的for循环语法和迭代器具有相同的效率。
这里有一些迭代数组的实现：</p>

<pre><code>//Java代码
static class Foo { 
    int mSplat; 
} 
Foo[] mArray = ... 
public void zero() {
     int sum = 0; 
     for (int i = 0; i mArray.length; ++i) { 
            sum += mArray[i].mSplat; 
            }
         }
 public void one() { 
    int sum = 0;
     Foo[] localArray = mArray;
     int len = localArray.length;
     for (int i = 0; i len; ++i) {
        sum += localArray[i].mSplat; 
    }
 }
 public void two() {
     int sum = 0;
     for (Foo a : mArray) { 
        sum += a.mSplat; 
        }
     }
</code></pre>

<p>zero()是当中最慢的，因为对于这个遍历中的历次迭代，JIT不能优化获取数组长度的开销。
One()稍快，将所有东西都放进局部变量中，避免了查找。但仅只有数组长度促使了性能的改善。
Two()是在无JIT的设备上运行最快的，对于有JIT的设备则和one()不分上下。他采用了JDK1.5中的改进for循环语法。
结论：优先采用改进的for循环，但在性能要求苛刻的ArrayList迭代中考虑采用手写计数循环。</p>

<h4>9. 在私有内部内中，考虑用包访问权限替代私有访问权限</h4>

<p>考虑下面的定义：</p>

<pre><code>//Java代码
public class Foo { 
    private class Inner {
         void stuff() {
             Foo.this.doStuff(Foo.this.mValue);
                 }
             }
    private int mValue; public void run() { 
        Inner in = new Inner();
        mValue = 27;
        in.stuff(); 
        }
    private void doStuff(int value) { 
        System.out.println("Value is " + value); 
        } 
    }
</code></pre>

<p>需要注意的关键是：我们定义的一个私有内部类(Foo$Inner)直接访问外部类中的一个私有方法和私有变量。这是合法的，代码也会打印出预期的Value is 27。
但问题是虚拟机认为从Foo$Inner中直接访问Foo的私有成员是非法的，因为他们是两个不同的类，尽管Java语言允许内部类访问外部类的私有成员，编译器生成几个综合方法来桥接这些间隙。</p>

<pre><code>//Java代码
/*package*/ 
static int Foo.access$100(Foo foo) { 
    return foo.mValue; 
    }
 /*package*/ 
static void Foo.access$200(Foo foo, int value) { 
    foo.doStuff(value); 
    }
</code></pre>

<p>内部类会在外部类中任何需要访问mValue字段或者doStuff方法的地方调用这些静态方法。这意味着这些代码将直接存取成员变量归结为通过存取器方法访问。之前提到存取器访问如何比直接访问慢，这例子说明，某些语言约定导致了不可见的性能问题。
如果你在高性能的Hotspot中使用这些代码，可以通过声明被内部类访问的字段和成员为包访问权限，而非私有。不幸的是这意味着这些字段会被其他处于同一个包中的类访问，因此在公共API中不宜采用。</p>

<h4>10. 合理利用浮点数</h4>

<p>通常的经验是，在Android设备中，浮点数会比整型慢两倍，在缺少FPU，或是JIT的G1以及有FPU和JIT的Nexus One中确实如此(两种设备间算数运算的绝对速度差大约是10倍).
速度术语中，在现代硬件上，float和double之间并没有不同。更广泛的讲，double大约2倍大。在没有存储空间问题的桌面机器中，double的优先级高于float。
但即使是整型，有些芯片拥有硬件乘法，却缺少除法。这种情况下，整型除法和求模运算是通过软件实现的，考虑下当你设计Hash表，或是做大量的算术。</p>

<h4>11. 了解并使用类库</h4>

<p>除了通常的那些有限选择类库代码而非自己的原因外，考虑到系统空闲时用手写的汇编程序来替代类库方法，这可能比JIT中能生成的最好的等效Java代码还要好。典型的例子就是String.indexOf，Dalvik用内部内联来替代。同样的，System.arraycopy方法比Nexus One中有JIT的自行编码循环快9倍.</p>

<h4>12. 合理利用本地方法</h4>

<p>本地方法并不是一定比Java高效，至少，Java和native之间过渡的关联是有消耗的。而JIT并不能越过这个界限进行优化。当你分配本地资源时(本地堆上的内存，文件说明符等)，往往很难实时的回收这些资源。同时你也需要在各个结构中编译你的代码，而非依赖JIT。甚至可能需要针对相同的架构来编译出不同版本：针对ARM处理器的GI编译的本地代码，并不能充分利用Nexus One上的ARM，而针对Nexus One上ARM编译的本地代码不能在G1的ARM上运行。
当存在有你想部署到Android上的本地代码库时，本地代码显得尤为有用，而非为了Java应用程序的提速。
结语
最后：通常权衡的，先确定存在问题，再进行优化。确认你知道当前的性能，否则无法衡量你进行尝试所得到的提升。
这份文档中的每个主张都有基准测试作为支持。你可以在code.google.com的dalvik项目中找到基准测试的代码。
基准测试是用Caliper Java微基准测试框架构建的。微基准测试很难走对，Caliper帮你完成了其中的困难工作。即使当你察觉某些情况的测试结果并非你所想象的那样(虚拟机总是在优化你的代码那)。我们强烈推荐你用Caliper来运行你自己的微基准测试。
同时你也会发现Traceview对分析很有用，但必须了解，他目前是不支持JIT的，这可能导致那些在JIT上可以胜出的代码超时。特别重要的，当根据Taceview的数据作出更改后，确保代码在没有Traceview时，确实跑的快了。</p>
]]></content>
  </entry>
  
</feed>
