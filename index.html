
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>临渊羡鱼不如退而结网</title>
  <meta name="author" content="武文涛">

  
  <meta name="description" content="本文将会根据以下几个问题进行讨论 • 为什么要选择架构模式开发? • 架构模式做的事情? • 主流架构MVC、MVP的介绍及区别? • 开发中如何选择合适的架构模式? &mdash;&ndash;为什么要选择架构模式开发？ 首先， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://wentao1990.github.io/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="临渊羡鱼不如退而结网" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//libs.baidu.com/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">临渊羡鱼不如退而结网</a></h1>
  
    <h2>你所浪费的今天,是昨天死去的人奢望的明天;你所厌恶的现在,是未来的你回不去的曾经;</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.baidu.com" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="wentao1990.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">文章</a></li>
  <li><a href="/blog/archives">档案</a></li>
  <li><a href="/aboutme">关于</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2017/03/01/android-mvp/">Android开发之架构模式选择</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2017-03-01T21:20:25+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2017</span></span> <span class='time'>9:20 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>本文将会根据以下几个问题进行讨论</h3>

<h5>• 为什么要选择架构模式开发?</h5>

<h5>• 架构模式做的事情?</h5>

<h5>• 主流架构MVC、MVP的介绍及区别?</h5>

<h5>• 开发中如何选择合适的架构模式?</h5>

<h3>&mdash;&ndash;为什么要选择架构模式开发？</h3>

<p>首先，让我们思考一下为什么在Android开发中如此迫切地需要一个清晰的软件架构。</p>

<p><strong>Activity是上帝类</strong></p>

<p>该段摘自“代码大全第二版”：</p>

<blockquote><p>避免创建神类。避免创建无所不知，无所不能的上帝类。如果一个类需要花费时间从其他类中通过Get()和Set()检索数据（也说，需要深入业务并且告诉它们如何去做），所以是否应该把这些功能函数更好的组织到其它类而不是上帝类中。（Riel 1996）</p></blockquote>

<p>上帝类的维护成本很高，你很难理解正在进行的操作，并且难以测试和扩展，这就是为什么要避免创建上帝类的黄金法则。</p>

<p>然而，在Android开发中，如果你不考虑架构的话，Activity类往往会越来越大。这是因为，在Android中，允许View和其它线程共存于Activity内。其实最大的问题莫过于在Activity中同时存在业务逻辑和UI逻辑。这会增加测试和维护的成本。</p>

<p>这是为什么需要清晰架构的原因之一。不仅会造成Activity的臃肿，还会引起其他问题，如使Activity和Fragment的生命周期变复杂，以及数据绑定等。  </div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2017/03/01/android-mvp/">阅读更多 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/10/06/android-01/">Android第三方网络请求框架总结</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-10-06T22:36:35+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>6</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>10:36 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>android-async-http （<a href="https://github.com/loopj/android-async-http">https://github.com/loopj/android-async-http</a>）</h4>

<p>功能：</p>

<p>•基于HttpClient；</p>

<p>•在UI线程外，异步进行http请求；</p>

<p>•在匿名回调中处理请求结果，callBback使用了Android的Handler发送消息机制在创建它的线程中执行；</p>

<p>•自动智能请求重试；</p>

<p>•持久化cookie存储，保存cookie到应用程序的SharedPreferences中；</p>

<p>开发者使用：</p>

<p>作者已经停止对该项目维护，在android 5.0 以后，不推荐使用HttpClient,所以不推荐使用此库。</p>

<h4>Volley  （<a href="https://github.com/stormzhang/AndroidVolley">https://github.com/stormzhang/AndroidVolley</a>）</h4>

<p>功能：</p>

<p>•基于HttpUrlConnection;</p>

<p>•封装了URL图片加载框架，支持图片加载；</p>

<p>•网络请求的排序，优先级处理</p>

<p>•缓存</p>

<p>•多级别取消请求</p>

<p>•Activity和生命周期的联动（Activity结束时同时取消所有网络请求）</p>

<p>性能：</p>

<p>可扩展性好：可支持HttpClient、HttpUrlConnection和OKHttp;</p>

<p>开发者使用：</p>

<p>封装性好，简单易用。</p>

<p>应用场景：</p>

<p>• 适合简单轻量级网络交互：网络请求频繁，传输数据小；</p>

<p>• 不能进行大数据量的网络操作（下载视频、音频等），所以不适合用来上传文件；</p>

<p>备注：Volley的request和response都是吧数据放到byte数组里，不支持输入输出流，把数据放到数组中，如果大文件多了，数组就会非常的大
且多，消耗内存，所以不如直接返回Stream那样具备可操作性，比如下载一个大文件，不可能把整个文件都缓存到内存之后在写到文件里。</p>

<h4>OKHttp （<a href="https://github.com/square/okhttp">https://github.com/square/okhttp</a>）</h4>

<p>功能：</p>

<p>• 高性能Http请求库，可以把它理解成是一个封装之后类似HttpUrlConnection的东西，属于同级并不是基于上述二者；</p>

<p>• 支持SPDY，共享同一个Socket来处理同一个服务器的所有请求；</p>

<p>• 支持http 2.0、websocket；</p>

<p>• 支持同步、异步；</p>

<p>• 封装了线程池、数据转换、参数使用、错误处理等；</p>

<p>• 无缝的支持GZIP来减少数据流量；</p>

<p>• 缓存响应数据来减少重复的网络请求</p>

<p>• 能从很多常用的连接问题中自动恢复；</p>

<p>• 解决了代理服务器问题和SSL握手失败问题；</p>

<p>性能：</p>

<p>基于NIO 和 Okio，所有性能更好：请求、处理速度快（IO:阻塞式； NIO：非阻塞式；Okio 是 Square 公司基于 IO 和NIO 基础上做的一个更简单、高效处理数据流的一个库）；</p>

<p>开发者使用：</p>

<p>• Api调用更加简单、方便；</p>

<p>• 使用时需要进行多一层封装；</p>

<p>应用场景：</p>

<p>重量级网络交互场景：网络请求频繁、传输数据量大（其实更推荐Retrofit,反正Retrofit是基于 OKHttp的）；</p>

<p>备注：</p>

<p>Android 4.4 的源码中可以看到，HttpUrlConnection已经替换成OkHttp实现了，所以我们更有理由相信OkHttp的强大；</p>

<h4>Retrofit （<a href="https://github.com/square/retrofit">https://github.com/square/retrofit</a>）</h4>

<p>功能：</p>

<p>• 基于OkHttp</p>

<p>• RESTful Api 设计风格</p>

<p>• 支持同步、异步；</p>

<p>• 通过注解配置请求（包括请求方法、请求参数、请求头、返回值等）</p>

<p>• 可以搭配多种Connverter 将获得的数据解析&amp;序列化</p>

<p>• 支持Gson(默认）、Jackson 、Protobuf等</p>

<p>• 支持对 RXjava 的支持；</p>

<p>性能：</p>

<p>• 性能最好，处理最快；</p>

<p>• 扩展性差（高度封装所带来的必然后果；解析数据都是使用统一的converter，如果服务器不能给出统一的API形式，将很难进行处理。</p>

<p>开发者使用：</p>

<p>• 简洁易用（RestfulAPI设计风格）；</p>

<p>• 代码简化（更加高度的封装和注解用法）；</p>

<p>• 解耦的更彻底、职责更细分；</p>

<p>• 易于其它框架联合使用（RXjava）；</p>

<p>• 使用方法较多，原理复杂，存在一定门槛；</p>

<p>应用场景：</p>

<p>任何场景下优先选择，特别是：后台API遵循RESTful的风格&amp;项目中有使用RXjava;</p>

<h4>总结：</h4>

<p>网络请求库没有说哪个最好，只有最合适，只有真的了解其使用场景才能很好的选择网络请求库。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/09/android-01/">Android性能优化</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-09T19:50:35+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>9</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>7:50 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>网络相关优化</h4>

<p>1.http头信息带Cache-Control域，确定缓存过期时间，防止重复请求。</p>

<p>2.直接用IP直连，不用域名，策略性更新本地IP列表。-DNS解析过程耗时百毫秒左右，并且还有可能存在DNS劫持。</p>

<p>3.图片、JS、CSS等静态资源，采用CDN（7牛之类的第三方服务已经搭建部署好了）</p>

<p>4.全局图片处理采用漏斗模型全局掌控，所请求的图片大小依照业务大小提供（最大不超过屏幕分辨率需要），如果请求原图，也不要超过 GL10.GL_MAX_TEXTURE_SIZE。</p>

<p>5.全局缩略图直接采用webp，在尽可能不损失图片质量的前提下，图片大小与png缩小30%~70%。</p>

<p>6.如果列表里的缩略图服务器处理好的小图，可以考虑直接在列表数据请求中，直接以base64在列表数据中直接带上图片（国内还比较少，海外有些这种做法，好像web端比较常见）</p>

<p>7.轮询或者socket心跳采用系统 AlarmManager提供的闹钟服务来做，保证在系统休眠的时候cpu可以得到休眠，在需要唤醒时可以唤醒（持有cpu唤醒锁）</p>

<p>8.可以通过将零散的网路的请求打包进行一次操作，避免过多的无线信号引起电量消耗。</p>

<h4>传输数据格式选择</h4>

<p>1.如果是需要全局数据的，考虑使用Protobuffers(序列化反序列化性能高于Json)，并且考虑使用 nano protocol buffer。</p>

<p>2.如果传输回来的数据不需要全量读取，考虑使用 Flatbuffers (序列化反序列化几乎不耗时，耗时是在读取对象时(就这一部分如果需要优化，可以参看 Flatbuffer Use Optimize</p>

<h4>输入流</h4>

<p>使用具有缓存策略的输入流</p>

<pre><code>   原            建议替换为
InputStream    BufferedInputStream
Reader         BufferedReader
</code></pre>

<h4>数据结构</h4>

<p>如果已知大概需要多大，就直接给初始大小，减少扩容时额外开销。</p>

<p>•ArrayList :里面就一数据，内存小，有序取值快，扩容效率低。</p>

<p>•LinkedList :里面就一双向链表，内存大，随机插入删除快，扩容率高。</p>

<p>•HashSet :里面就HashMap,用key对外存储，目的就是不允许重复元素。</p>

<p>•ConcruuenHashMap :线程安全，采用细分锁，锁颗粒更小，并发性能更优.</p>

<p>•Collections.synchronizedMap : 线程安全，采用当前对象作为锁，颗粒较大，并发性能较差。</p>

<p>•SparseArray、 SparseBooleanArray、 SparseIntArray: 针对Key为 Int、 Boolean进行了优化，采用二分法查找，简单数组存储。相比 HashMap而言， HashMap每添加一个数据，大约会需要申请额外的32字节的数据，因此 Sparsexxx在内存方面的开销会小很多。</p>

<h4>编码习惯</h4>

<p>1.尽量简化，不做没必要的操作。</p>

<p>2.尽量避免分配内存（创建对象）。</p>

<p>3.如果你确定不需要访问类成员，就把方法static，这样调用速度可以提升15%~20%，因为不需要切换对象状态。</p>

<p>4.如果某个参数是常量，要加上static final ,这样可以让Class首次初始化的时候不用调用<clinit>来创建 static方法，而是在编译时就直接将常量替换代码中使用的位置。</p>

<p>5.Android开发中，类内尽量避免通过 get/set访问成员变量，虽然这在语言的开发中是一个好的习惯，但是Android虚拟机中，对方法的调用开销远大于对变量的直接访问。在没有JIT的情况下，直接的变量访问比调用方法快3倍，在JIT下，直接的变量访问更是比调用方法快7倍!</p>

<p>6.当内部类需要访问外部类的私有 方法/变量时，考虑将这些外部类的私有 方法/变量改用包可见的方式。首先在编写代码的时候，通过内部类访问外部类的私有 方法/变量是合法的，但是在编译的时候为了满足这个会将需要被内部类访问的私有 方法/变量封装一层包可见的方法，实现让内部类访问这些私有的 方法/变量，根据前面我们有提到说方法的调用开销大于变量的调用，因此这样使得性能变差，所以我们在编码的时候可以考虑直接将需要被内部类调用的外部类私有 方法/变量，改为包可见。</p>

<p>7.尽量少使用 float。在很多现代设备中， double的性能与 float的性能几乎没有差别，但是从大小上面 double是 float的两倍的大小。</p>

<p>8.尽量考虑使用整型而非浮点数，在较好的Android设备中，浮点数比整型慢一倍。</p>

<p>9.尽量不要使用除法操作，有很多处理器有乘法器，但是没有除法器，也就是说在这些设备中需要将除法分解为其他的计算方式速度会比较慢。</p>

<p>10.尽量使用系统sdk中提供的方法，而非自己去实现。如 String.indexOf()相关的API，Dalvik将会替换为内部方法； System.arraycopy()方法在Nexus One手机上，会比我们上层写的类似方法的执行速度快9倍。</p>

<p>11.谨慎编写native，性能不一定更好，Native并不是用于使得性能更好，而是用于有些已经存在的库是使用native语言实现的，我们需要引入Android，这时才使用。1) 需要多出开销在维持Java-native的通信；2) 在native中创建的资源由于在native heap上面，因此需要主动的释放；3) 需要对不同的处理器架构进行支持，存在明显的兼容性问题需要解决。</p>

<p>12.在没有JIT的设备中，面向接口编程的模式(如 Map map)，相比直接访问对象类(如 HashMap map)，会慢6%，但是在存在JIT的设备中，两者的速度差不多。但是内存占用方面面向接口变成会消耗更多内存，因此如果你的面向接口编程不是十分的必要的情况下可以考虑不用。</p>

<p>13.在没有JIT的设备中，访问本地化变量相对与成员变量会快20%，但是在存在JIT的设备中，两者速度差不多。</p>

<h4>遍历优化</h4>

<p>尽量使用 Iterable而不是通过长度判断来进行遍历。</p>

<pre><code>// 这种性能是最差的，JIT也无法对其优化。
public void zero() {
    int sum = 0;
    for (int i = 0; i &lt; mArray.length; ++i) {
        sum += mArray[i].mSplat;
    }
}
// 相对zero()来说，这种写法会更快些，在存在JIT的情况下速度几乎和two()速度一样快。
public void one() {
    int sum = 0;
    // 1) 通过本地化变量，减少查询，在不存在JIT的手机下，优化较明显。
    Foo[] localArray = mArray;
    // 2) 获取队列长度，减少每次遍历访问变量的长度，有效优化。
    int len = localArray.length;
    for (int i = 0; i &lt; len; ++i) {
        sum += localArray[i].mSplat;
    }
}
// 在无JIT的设备中，是最快的遍历方式，在存在JIT的设备中，与one()差不多快。
public void two() {
    int sum = 0;
    for (Foo a : mArray) {
        sum += a.mSplat;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/07/android-performs1/">转：Android最佳性能实践——合理管理内存</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-07T13:42:26+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>1:42 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>原文：<a href="http://blog.csdn.net/guolin_blog/article/details/42238627">http://blog.csdn.net/guolin_blog/article/details/42238627</a></p>

<p>注意本系列文章的内容基本源于Android Doc，如果想要阅读更加详细的关于性能方面的资料，可以直接去阅读Android官方文档。</p>

<p>内存(RAM)对于任何一个软件开发环境都是种非常珍贵的资源，而对于移动操作系统来讲的话，则会显得更加珍贵，因为手机的硬件条件相对于PC毕竟是比较落后的。尽管Android系统的虚拟机拥有自动回收垃圾的机制，但这并不代表我们就可以忽视应该在什么时候分配和释放内存。</p>

<p>为了使垃圾回收器可以正常释放程序所占用的内存，在编写代码的时候就一定要注意尽量避免出现内存泄漏的情况（通常都是由于全局成员变量持有对象引用所导致的），并且在适当的时候去释放对象引用。对于大多数的应用程序而言，后面其它的事情就可以都交给垃圾回收器去完成了，如果一个对象的引用不再被其它对象所持有，那么系统就会将这个对象所分配的内存进行回收。</p>

<p>我们在开发软件的时候应当自始至终都把内存的问题充分考虑进去，这样的话才能开发出更加高性能的软件。而内存问题也并不是无规律可行的，Android系统给我们提出了很多内存优化的建议技巧，只要按照这些技巧来编写程序，就可以让我们的程序在内存性能发面表现得相当不错，下面我们就来一一学习一下这些技巧。  </div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/08/07/android-performs1/">阅读更多 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/07/19/server/">如何快速搭建一个完整的移动直播系统？</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-07-19T22:53:30+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>19</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>10:53 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>移动直播行业的火热会在很长一段时间内持续，通过和各行业的整合，从而成为具有无限可能性的行业。主要有以下三个原因：</p>

<p>第一，移动直播的UGC生产模式比PC端的直播更明显，人人都有设备，随时随地开播，完全顺应了互联网时代的开放性原则，能刺激更多人去创造和传播优质内容。</p>

<p>第二，网络带宽和速度在逐渐提高，网络成本在逐渐下降，为移动直播提供一个极佳的发展环境。文字、声音、视频、游戏等都会在移动直播中呈现，创造出更加丰富的用户体验。 直播可以以SDK的形式接入到自己的应用中 ，比如，教育领域中的课后辅导完全可以以直播的形式开展业务、电商也可借助直播让用户挑选商品，促进销售。 </div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/07/19/server/">阅读更多 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/05/23/android-server/">Service与 IntentService 的区别与使用场景</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-05-23T17:50:35+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2016</span></span> <span class='time'>5:50 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>1.IntentService是继承自Service的</h4>

<h4>2.Service不是一个单独的进程 ，它和应用程序在同一个进程中。</h4>

<h4>3.Service不是一个线程，所以我们应该避免在Service里面进行耗时的操作</h4>

<h4>4.IntentService相对于Service来说，有几个非常有用的优点</h4>

<p>IntentService使用队列的方式将请求的Intent加入队列，然后开启一个worker thread(线程)来处理队列中的Intent，对于异步的startService请求，IntentService会处理完成一个之后再处理第二个，每一个请求都会在一个单独的worker thread中处理，不会阻塞应用程序的主线程，这里就给我们提供了一个思路，如果有耗时的操作与其在Service里面开启新线程还不如使用IntentService来处理耗时操作。 </div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/05/23/android-server/">阅读更多 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/04/08/android-imageview/">自定义任意形状的ImageView</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-04-08T22:22:25+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>10:22 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>参考</h4>

<p>Xfermode in android - 解释文档和模式部分写得很好
Android中Canvas绘图之PorterDuffXfermode使用及工作原理详解 - 代码实践分析部分值得细看</p>

<p>网上大部分文章都说有3个类可用, 但是实际上仅需要掌握PoterDuffXfermode, 因为只有它支持硬件加速, 官方的文档的描述中Xfermode的直接继承类也只有它了, 所以一般只用它.</p>

<p>PoterDuffXfermode</p>

<p>Porter-Duff 操作是 1 组 12 项用于描述数字图像合成的基本手法，包括Clear、Source Only、Destination Only、Source Over、Source In、SourceOut、Source Atop、Destination Over、Destination In、DestinationOut、Destination Atop、XOR。通过组合使用 Porter-Duff 操作，可完成任意 2D图像的合成。Thomas Porter 和 Tom Duff 发表于 1984年原始论文的扫描版本
简单来说就是一种图像合成的理论依据, 规定了合成图像时的像素操作. Android中支持总共18种模式, 就不一一列举了. 看懂文档就行.</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/04/08/android-imageview/">阅读更多 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/01/11/android-iptcphttp/">IP/TCP/UDP/HTTP浅谈</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-01-11T18:46:25+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>6:46 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>前言：</h4>

<p>在世界上各地，各种各样的电脑运行着各自不同的操作系统为大家服务，这些电脑在表达同一种信息的时候所使用的方法是千差万别。就好像圣经中上帝打乱了各地人的口音，让他们无法合作一样。计算机使用者意识到，计算机只是单兵作战并不会发挥太大的作用。只有把它们联合起来，电脑才会发挥出它最大的潜力。于是人们就想方设法的用电线把电脑连接到了一起。但是简单的连到一起是远远不够的，就好像语言不同的两个人互相见了面，完全不能交流信息。因而他们需要定义一些共通的东西来进行交流，TCP/IP就是为此而生。TCP/IP不是一个协议，而是一个协议族的统称。里面包括了IP协议，IMCP协议，TCP协议，以及我们更加熟悉的http、ftp、pop3协议等等。电脑有了这些，就好像学会了外语一样，就可以和其他的计算机终端做自由的交流了。  </div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/01/11/android-iptcphttp/">阅读更多 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/02/android-image/">Android Image</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-11-02T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2015</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><blockquote><hr />

<p>layout: post
title: &ldquo;&lt;转>Android高效加载大图、多图解决方案，有效避免程序OOM&rdquo;
date: 2015-11-02 16:46:35 +0800
comments: true</p>

<h2>categories: android</h2></blockquote>

<p>原文：<a href="http://blog.csdn.net/guolin_blog/article/details/9316683">http://blog.csdn.net/guolin_blog/article/details/9316683</a></p>

<p>本篇文章主要内容来自于Android Doc，我翻译之后又做了些加工，英文好的朋友也可以直接去读原文。</p>

<p><a href="http://developer.android.com/training/displaying-bitmaps/index.html">http://developer.android.com/training/displaying-bitmaps/index.html</a></p>

<h4>高效加载大图片</h4>

<p>我们在编写Android程序的时候经常要用到许多图片，不同图片总是会有不同的形状、不同的大小，但在大多数情况下，这些图片都会大于我们程序所需要的大小。比如说系统图片库里展示的图片大都是用手机摄像头拍出来的，这些图片的分辨率会比我们手机屏幕的分辨率高得多。大家应该知道，我们编写的应用程序都是有一定内存限制的，程序占用了过高的内存就容易出现OOM(OutOfMemory)异常。我们可以通过下面的代码看出每个应用程序最高可用内存是多少。  </div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/11/02/android-image/">阅读更多 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/08/12/android-commonAdapter/">打造可以共用的Adapter</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-12T19:14:31+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>12</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>7:14 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>前言：</h3>

<p>在我们开发android项目中，会在多个地方使用ListView展示内容，然后每个ListView都要对应一个Adapter来装载数据。这样的话代码就会有许多的冗余，就算写个BaseAdapter抽取部分代码，也有很多的冗余代码避免不了，至少那十几个类文件是确确实实存在那的（取决于项目需求）。下面我们来一起打造一个共用的Adapter,一个搞定所有ListView的数据装载。</p>

<h5>传统的写法我就不贴出来了，自己回想一下大概就很清楚了。</h5>

<h3>第一步：打造共用的ViewHolder</h3>

<p>一个有经验的开发者在写Adapterd的时候是不会忘记写ViewHolder的，而ViewHolder无非就是item的复用，解决效率和负载问题。所以，若要打造一个共用的Adapter，那么一个共用的ViewHolder是必不可少的。</p>

<p>ViewHolder的原理是通过convertView.setTag(this)与convertView进行绑定,然后当convertView被复用时，直接通过getTag方法拿到ViewHolder对象，直接操作里面封装的convertView中的控件，从而省去了findViewById的时间。也就说，每个convertView都会绑定一个ViewHolder对象来存储布局中的控件。那么我们只要写出一个通用的ViewHolder，然后对于任意的convertView，提供一个对象让其setTag即可；</p>

<p> </div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/08/12/android-commonAdapter/">阅读更多 &rarr;</a>
    </footer>
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section> 
  <h1>文章分类</h1> 
  <ul id="categories"> 
    <li class='category'><a href='/blog/categories/android/'>android (25)</a></li>
<li class='category'><a href='/blog/categories/hardware/'>hardware (1)</a></li>
<li class='category'><a href='/blog/categories/java/'>java (1)</a></li>
<li class='category'><a href='/blog/categories/mysql/'>mysql (1)</a></li>
<li class='category'><a href='/blog/categories/server/'>server (1)</a></li>
<li class='category'><a href='/blog/categories/unity3d/'>unity3d (1)</a></li>
<li class='category'><a href='/blog/categories/web/'>web (2)</a></li>
 
  </ul> 
</section><section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2017/03/01/android-mvp/">Android开发之架构模式选择</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/10/06/android-01/">Android第三方网络请求框架总结</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/09/android-01/">Android性能优化</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/07/android-performs1/">转：Android最佳性能实践——合理管理内存</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/07/19/server/">如何快速搭建一个完整的移动直播系统？</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2017 - 武文涛 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
